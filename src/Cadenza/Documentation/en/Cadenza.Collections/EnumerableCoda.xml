<Type Name="EnumerableCoda" FullName="Cadenza.Collections.EnumerableCoda">
  <TypeSignature Language="C#" Value="public static class EnumerableCoda" />
  <AssemblyInfo>
    <AssemblyName>Cadenza</AssemblyName>
    <AssemblyVersion>0.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <ThreadingSafetyStatement>
    This type is thread safe.
  </ThreadingSafetyStatement>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      Extension methods on
      <see cref="T:System.Collections.Generic.IEnumerable{T}" />.
    </summary>
    <remarks>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AggregateHistory&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AggregateHistory&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="func">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateHistory&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TAccumulate&gt; AggregateHistory&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TAccumulate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <typeparam name="TAccumulate">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="seed">To be added.</param>
        <param name="func">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateHistory&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; AggregateHistory&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <typeparam name="TAccumulate">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="seed">To be added.</param>
        <param name="func">To be added.</param>
        <param name="resultSelector">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateHistory``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateReverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource AggregateReverse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="func">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateReverse&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate AggregateReverse&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <typeparam name="TAccumulate">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="seed">To be added.</param>
        <param name="func">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateReverse&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult AggregateReverse&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <typeparam name="TAccumulate">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="seed">To be added.</param>
        <param name="func">To be added.</param>
        <param name="resultSelector">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateReverseHistory&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AggregateReverseHistory&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="func">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateReverseHistory&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TAccumulate&gt; AggregateReverseHistory&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TAccumulate&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <typeparam name="TAccumulate">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="seed">To be added.</param>
        <param name="func">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AggregateReverseHistory&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; AggregateReverseHistory&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <typeparam name="TAccumulate">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="seed">To be added.</param>
        <param name="func">To be added.</param>
        <param name="resultSelector">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverseHistory``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static bool And (this System.Collections.Generic.IEnumerable&lt;bool&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;System.Boolean&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Apply&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static void Apply&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyPairs&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; ApplyPairs&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Action&lt;TSource&gt;[] actions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="actions" Type="System.Action&lt;TSource&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="actions">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ApplyPairs``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0}[])" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AsIList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IList&lt;TSource&gt; AsIList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Break&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; Break&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,bool&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="func">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Cache&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Collections.CachedSequence&lt;T&gt; Cache&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Collections.CachedSequence&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Collections.SequenceComparison&lt;T&gt; CompareWith&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; self, System.Collections.Generic.IEnumerable&lt;T&gt; update);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Collections.SequenceComparison&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
        <Parameter Name="update" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the elements within <paramref name="self" /> and <paramref name="update" /></typeparam>
        <param name="self">The original enumeration of elements.</param>
        <param name="update">The updated enumeration of elements to compare against.</param>
        <summary>Compares two enumerations retrieving added, removed and unchanged elements.</summary>
        <returns>An <see cref="T:Cadenza.Collections.SequenceComparison{T}" /> containing the added, removed and unchanged elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="update" /> is <c>null</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Collections.SequenceComparison&lt;T&gt; CompareWith&lt;T&gt; (this System.Collections.Generic.IEnumerable&lt;T&gt; self, System.Collections.Generic.IEnumerable&lt;T&gt; update, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Collections.SequenceComparison&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" RefType="this" />
        <Parameter Name="update" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the elements within <paramref name="self" /> and <paramref name="update" /></typeparam>
        <param name="self">The original enumeration of elements.</param>
        <param name="update">The updated enumeration of elements to compare against.</param>
        <param name="comparer">The <see cref="System.Collections.Generic.IEqualityComparer{T}" /> used to compare equality.</param>
        <summary>Compares two enumerations retrieving added, removed and unchanged elements.</summary>
        <returns>An <see cref="T:Cadenza.Collections.SequenceComparison{T}" /> containing the added, removed and unchanged elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="update" /> is <c>null</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; selfs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selfs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="selfs">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, System.Collections.Generic.IEnumerable&lt;TSource&gt;[] selfs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selfs" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="selfs">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContiguousSubsequences&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; ContiguousSubsequences&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, int windowSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="windowSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="windowSize">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cycle&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Cycle&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Each&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Each&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Action&lt;TSource,int&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="action" Type="System.Action&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Each``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Each&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Each&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Action&lt;TSource&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="action" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Each``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ExceptLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; ExceptLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ExceptLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" /></exception>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ExceptLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ExceptLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; ExceptLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">To be added; from: <see cref="M:Cadenza.Collections.EnumerableCoda.ExceptLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" /></exception>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,bool&gt; predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="predicate">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndices&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; FindIndices&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,bool&gt; predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="predicate">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Action&lt;TSource,int&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="action" Type="System.Action&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Action&lt;TSource&gt; action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="action" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="HaskellGroup&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; HaskellGroup&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="HaskellGroupBy&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; HaskellGroupBy&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,TSource,bool&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the elements to turn into groups.
        </param>
        <param name="func">
          A <see cref="T:System.Func{TSource,TSource,System.Boolean}" /> which is
          used to determine whether the <typeparamref name="TSource" /> 
          elements belong to the same group.
        </param>
        <summary>
          Split <paramref name="self" /> into a sequence of groups.
        </summary>
        <returns>
          An <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          of groups.
        </returns>
        <remarks>
          <para>
            A group is a continguence sequence of elements from 
            <paramref name="self" /> for which
            <c><paramref name="func" />(firstItemInTheGroup, currentItemInTheGroup)</c>
            returns <see langword="true" />.  Once <paramref name="func" /> 
            returns <see langword="false" />, a new group is created (and the 
            next element within <paramref name="self" /> is the first element
            of the new group).
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#HaskellGroupBy">// Split a string into pairs
string s = "123456789";
int c = 0;
List&lt;List&lt;char&gt;&gt; pairs = s.HaskellGroupBy(delegate {
	++c;
	if (c &lt; 2)
		return true;
	c = 0;
	return false;
}).ToList();
Assert.AreEqual(5, pairs.Count);
Assert.IsTrue(new[]{'1', '2'}.SequenceEqual (pairs [0]));
Assert.IsTrue(new[]{'3', '4'}.SequenceEqual (pairs [1]));
Assert.IsTrue(new[]{'5', '6'}.SequenceEqual (pairs [2]));
Assert.IsTrue(new[]{'7', '8'}.SequenceEqual (pairs [3]));
Assert.IsTrue(new[]{'9'}.SequenceEqual (pairs [4]));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="func" /> is 
          <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Implode&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static string Implode&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Selector(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Implode&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static string Implode&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, string separator);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="separator" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="separator">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Selector(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Implode&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static string Implode&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, string separator, Func&lt;TSource,string&gt; selector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.String&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="separator">To be added.</param>
        <param name="selector">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Selector(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, System.Collections.Generic.IEnumerable&lt;TSource&gt; values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Values(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfAny&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource[] values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="values" Type="TSource[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Values(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="IndicesOf&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; IndicesOf&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="IndicesOfAny&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; IndicesOfAny&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, System.Collections.Generic.IEnumerable&lt;TSource&gt; values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Values(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="IndicesOfAny&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; IndicesOfAny&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource[] values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="values" Type="TSource[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Values(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="InitialSegments&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; InitialSegments&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence for which to return the initial segments.
        </param>
        <summary>
          Creates a 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing all leading segments of <paramref name="self" />,
          shortest first.
        </summary>
        <returns>
          A 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing all leading segments of <paramref name="self" />,
          shortest first.
        </returns>
        <remarks>
          <para>
            A "leading segment" is the list of <typeparamref name="TSource" />
            values preceding the "current" index, in which the current index
            starts at the start of <paramref name="self" /> and increments
            until the end of <paramref name="self" />.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#InitialSegments">IEnumerable&lt;IEnumerable&lt;char&gt;&gt; e = "abc".InitialSegments ();
var l = e.ToList ();
Assert.AreEqual (4, l.Count);
AssertAreSame (new char[]{},          l [0]);
AssertAreSame (new[]{'a'},            l [1]);
AssertAreSame (new[]{'a', 'b'},       l [2]);
AssertAreSame (new[]{'a', 'b', 'c'},  l [3]);
</code>
        </remarks>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.TrailingSegments``1(System.Collections.Generic.IEnumerable{``0})" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Insert&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Insert&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Insert&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Insert&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource value, Func&lt;TSource,TSource,int&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="value">To be added.</param>
        <param name="func">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Intersperse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersperse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; self, System.Collections.Generic.IEnumerable&lt;TSource&gt; between);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;" RefType="this" />
        <Parameter Name="between" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="between">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Intersperse``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.IEnumerable{``0})" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Intersperse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersperse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static bool Or (this System.Collections.Generic.IEnumerable&lt;bool&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;System.Boolean&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByNatural&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; OrderByNatural&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,string&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,System.String&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="func">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Partition&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; Partition&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,bool&gt; predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="self">To be added.</param>
        <param name="predicate">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="PathCombine">
      <MemberSignature Language="C#" Value="public static string PathCombine (this System.Collections.Generic.IEnumerable&lt;string&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="self">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveFirstOccurrence&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; RemoveFirstOccurrence&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence from which to remove the first element
          equal to <paramref name="value" />.
        </param>
        <param name="value">
          A <typeparamref name="TSource" /> which is the value
          to remove once from <paramref name="self" />.
        </param>
        <summary>
          Removes the first occurrence of
          <paramref name="value" /> from the sequence <paramref name="self" />.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which is a copy of <paramref name="self" />
          in which the first occurrence of
          <paramref name="value" /> has been removed.
        </returns>
        <remarks>
          <para>
            This is equivalent to calling
            <c><paramref name="self" />.RemoveFirstOccurrence(<paramref name="value" />,
            <see langword="null" />)</c>.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#RemoveFirstOccurrence">Assert.AreEqual ("bnana",
		"banana".RemoveFirstOccurrence ('a').Implode ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.RemoveFirstOccurrence``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFirstOccurrence&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; RemoveFirstOccurrence&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence from which to remove the first element
          equal to <paramref name="value" />.
        </param>
        <param name="value">
          A <typeparamref name="TSource" /> which is the value
          to remove once from <paramref name="self" />.
        </param>
        <param name="comparer">
          A <see cref="T:System.Collections.Generic.IEqualityComparer{TSource}" />
          to use when comparing elements from <paramref name="self" />
          to <paramref name="value" />. If <see langword="null" /> then
          <see cref="P:System.Collections.Generic.EqualityComparer{TSource}.Default" />
          is used.
        </param>
        <summary>
          Removes the first occurrence of
          <paramref name="value" /> from the sequence <paramref name="self" />.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which is a copy of <paramref name="self" />
          in which the first occurrence of
          <paramref name="value" /> has been removed.
        </returns>
        <remarks>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#RemoveFirstOccurrence">Assert.AreEqual ("bnana",
		"banana".RemoveFirstOccurrence ('a').Implode ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveFirstOccurrences&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; RemoveFirstOccurrences&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource value, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence from which to remove the leading elements
          equal to <paramref name="value" /> from.
        </param>
        <param name="value">
          A <typeparamref name="TSource" /> which is the value
          to remove from the start of <paramref name="self" />.
        </param>
        <param name="count">
          A <see cref="T:System.Int32" /> containing the number
          of <paramref name="value" /> elements to remove from
          <paramref name="self" />.
        </param>
        <summary>
          Removes the first <paramref name="count" /> occurrences of
          <paramref name="value" /> from the sequence <paramref name="self" />.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which is a copy of <paramref name="self" />
          in which the first <paramref name="count" /> occurrences of
          <paramref name="value" /> have been removed.
        </returns>
        <remarks>
          <para>
            This is equivalent to calling
            <c><paramref name="self" />.RemoveFirstOccurrences(<paramref name="value" />,
            <paramref name="count" />, <see langword="null" />)</c>.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#RemoveFirstOccurrences">Assert.AreEqual ("bnna",
		"banana".RemoveFirstOccurrences ('a', 2).Implode ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is negative.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.RemoveFirstOccurrences``1(System.Collections.Generic.IEnumerable{``0},``0,System.Int32,System.Collections.Generic.IEqualityComparer{``0})" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFirstOccurrences&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; RemoveFirstOccurrences&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TSource value, int count, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence from which to remove the leading elements
          equal to <paramref name="value" /> from.
        </param>
        <param name="value">
          A <typeparamref name="TSource" /> which is the value
          to remove from the start of <paramref name="self" />.
        </param>
        <param name="count">
          A <see cref="T:System.Int32" /> containing the number
          of <paramref name="value" /> elements to remove from
          <paramref name="self" />.
        </param>
        <param name="comparer">
          A <see cref="T:System.Collections.Generic.IEqualityComparer{TSource}" />
          to use when comparing elements from <paramref name="self" />
          and <paramref name="value" />. If <see langword="null" /> then
          <see cref="P:System.Collections.Generic.EqualityComparer{TSource}.Default" />
          is used.
        </param>
        <summary>
          Removes the first <paramref name="count" /> occurrences of
          <paramref name="value" /> from the sequence <paramref name="self" />.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which is a copy of <paramref name="self" />
          in which the first <paramref name="count" /> occurrences of
          <paramref name="value" /> have been removed.
        </returns>
        <remarks>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#RemoveFirstOccurrences">Assert.AreEqual ("bnna",
		"banana".RemoveFirstOccurrences ('a', 2).Implode ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is negative.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Repeat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, int number);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="number" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to repeat.
        </param>
        <param name="number">
          The number of times to repeat <paramref name="self" />.
        </param>
        <summary>
          Repeats the sequence <paramref name="self" /> for
          <paramref name="number" /> repetitions.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          sequence containing
          <c><paramref name="count" /> * <paramref name="self" />.Count()</c>
          elements, consisting of the sequence <paramref name="self" />,
          followed by the sequence <paramref name="self" />, etc.
        </returns>
        <remarks>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Repeat">Assert.AreEqual ("foofoofoo", new [] {"foo"}.Repeat (3).Implode ());
Assert.AreEqual ("foobarfoobar", new [] {"foo", "bar"}.Repeat (2).Implode ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SelectAggregated&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Tuple&lt;TAccumulate,System.Collections.Generic.List&lt;TResult&gt;&gt; SelectAggregated&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TAccumulate seed, Func&lt;TAccumulate,TSource,Cadenza.Tuple&lt;TAccumulate,TResult&gt;&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Tuple&lt;TAccumulate,System.Collections.Generic.List&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,Cadenza.Tuple&lt;TAccumulate,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <typeparam name="TAccumulate">
          The type of the accumulator value.
        </typeparam>
        <typeparam name="TResult">
          The type of the return value.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to return the values of successive
          <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
          and
          <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
          calls from.
        </param>
        <param name="seed">
          The first <typeparamref name="TAccumulate" /> value to pass to
          <paramref name="func" />.
        </param>
        <param name="func">
          A
          <see cref="T:System.Func{TAccumulate,TSource,Cadenza.Tuple{TAccumulate,TResult}}" />
          which is applied against each element within <paramref name="self" />
          and the current <paramref name="TAccumulate" />
          value (initially using <paramref name="seed" />), generating the
          next accumulated value and the (partial) result value.
        </param>
        <summary>
          Applies <paramref name="func" /> to each element within
          <paramref name="self" />, returning the final
          value of the accumulator and the list of intermediate values.
        </summary>
        <returns>
          A
          <see cref="T:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}" />
          which contains the final accumulated value in
          <see cref="P:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}.Item1" />
          and the list of intermediate results in
          <see cref="P:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}.Item2" />.
        </returns>
        <remarks>
          <para>This is Haskell's <c>mapAccumL</c>.</para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SelectAggregated">IEnumerable&lt;int&gt; s = new []{2, 3, 4, 5};
Tuple&lt;int, List&lt;string&gt;&gt; r = s.SelectAggregated (1,
		(a,b) =&gt; Tuple.Create (a-b, "s" + (a-b)));
Assert.AreEqual (-13, r.Item1);
Assert.IsTrue (new[]{
		"s-1",
		"s-4",
		"s-8",
		"s-13",
}.SequenceEqual (r.Item2));

r = new int[]{}.SelectAggregated (42,
		(a,b) =&gt; Tuple.Create (a-b, b.ToString ()));
Assert.AreEqual (42, r.Item1);
Assert.AreEqual (0, r.Item2.Count);
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="func" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SelectBreadthFirst&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectBreadthFirst&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,TResult&gt; valueSelector, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; childrenSelector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="valueSelector" Type="System.Func&lt;TSource,TResult&gt;" />
        <Parameter Name="childrenSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the root nodes and intermediate nodes of the tree.
        </typeparam>
        <typeparam name="TResult">
          The type of the object to return.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the elements to perform a breadth-first traversal on.
        </param>
        <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TResult}" /> which is used to
          convert tree nodes into <typeparamref name="TResult" /> instances.
        </param>
        <param name="childrenSelector">
          A <see cref="T:System.Func{TSource,System.Collections.Generic.IEnumerable{TSource}}" />
          which returns the child nodes of <paramref name="root" />
          and all intermediate non-leaf nodes.
        </param>
        <summary>
          Traverse a sequence of nodes in a breadth-first fashion, converting each
          encountered node.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the result of applying <paramref name="valueSelector" />
          to all nodes encountered while traversing the forest
          <paramref name="self" /> in a breadth-first fashion.
        </returns>
        <remarks>
          <para>
            <paramref name="self" /> is a "forest", a sequence of tree roots
            (siblings), wherein each
            node is a data structure containing a value and child nodes.
            The value is retrieved via <paramref name="valueSelector" />,
            and the children are obtained via
            <paramref name="childrenSelector" />.
          </para>
          <para>
            Each node is traversed in a breadth-first fashion, with each
            encountered node is provided to <paramref name="valueSelector" />,
            and the values are returned.
          </para>
        </remarks>
        <example>
          <para>
            Given the <c>TreeNode&lt;T&gt;</c> declaration:
          </para>
          <code lang="C#" src="../../Test/Cadenza/ObjectTest.cs#TreeNode_Declaration">class TreeNode&lt;T&gt;
{
	public TreeNode ()
	{
		Children = new TreeNode&lt;T&gt; [0];
	}

	public T Value;
	public IEnumerable&lt;TreeNode&lt;T&gt;&gt; Children;
}
</code>
          <para>
            <c>SelectBreadthFirst()</c> is used as:
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SelectBreadthFirst">TreeNode&lt;int&gt;[] root = new TreeNode&lt;int&gt;[] {
	new TreeNode&lt;int&gt; {
		Value = 1, Children = new [] {
			new TreeNode&lt;int&gt; { Value = 2 },
			new TreeNode&lt;int&gt; {
				Value = 3, Children = new [] {
					new TreeNode&lt;int&gt; { Value = 5 },
				}
			},
			new TreeNode&lt;int&gt; { Value = 4 },
		}
	},
	new TreeNode&lt;int&gt; { Value = -1 },
};
IEnumerable&lt;int&gt; values = root
	.SelectBreadthFirst (x =&gt; x.Value, x =&gt; x.Children);
AssertAreSame (new[]{ 1, 2, 3, 4, 5, -1 }, values);
</code>
        </example>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="self" /> is <see langword="null" />.
          </para>
          <para>-or-</para>
          <para>
            <paramref name="childrenSelector" /> is <see langword="null" />.
          </para>
          <para>-or-</para>
          <para>
            <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SelectDepthFirst&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectDepthFirst&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,TResult&gt; valueSelector, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; childrenSelector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="valueSelector" Type="System.Func&lt;TSource,TResult&gt;" />
        <Parameter Name="childrenSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the root nodes and intermediate nodes of the tree.
        </typeparam>
        <typeparam name="TResult">
          The type of the object to return.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the elements to perform a depth-first traversal on.
        </param>
        <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TResult}" /> which is used to
          convert tree nodes into <typeparamref name="TResult" /> instances.
        </param>
        <param name="childrenSelector">
          A <see cref="T:System.Func{TSource,System.Collections.Generic.IEnumerable{TSource}}" />
          which returns the child nodes of an element in
          <paramref name="self" /> (and grand-children, and
          great-grandchildren, and...).
        </param>
        <summary>
          Traverse a sequence of nodes in a depth-first fashion, converting each
          encountered node.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the result of applying <paramref name="valueSelector" />
          to all nodes encountered while traversing the forest
          <paramref name="self" /> in a depth-first fashion.
        </returns>
        <remarks>
          <para>
            <paramref name="self" /> is a "forest", a sequence of tree roots
            (siblings), wherein each
            node is a data structure containing a value and child nodes.
            The value is retrieved via <paramref name="valueSelector" />,
            and the children are obtained via
            <paramref name="childrenSelector" />.
          </para>
          <para>
            The tree is traversed in a depth-first fashion, each encountered
            node is provided to <paramref name="valueSelector" />, and the
            values are returned.
          </para>
        </remarks>
        <example>
          <para>
            Given the <c>TreeNode&lt;T&gt;</c> declaration:
          </para>
          <code lang="C#" src="../../Test/Cadenza/ObjectTest.cs#TreeNode_Declaration">class TreeNode&lt;T&gt;
{
	public TreeNode ()
	{
		Children = new TreeNode&lt;T&gt; [0];
	}

	public T Value;
	public IEnumerable&lt;TreeNode&lt;T&gt;&gt; Children;
}
</code>
          <para>
            <c>SelectDepthFirst()</c> is used as:
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SelectDepthFirst">TreeNode&lt;int&gt;[] root = new TreeNode&lt;int&gt;[] {
	new TreeNode&lt;int&gt; {
		Value = 1, Children = new [] {
			new TreeNode&lt;int&gt; { Value = 2 },
			new TreeNode&lt;int&gt; {
				Value = 3, Children = new [] {
					new TreeNode&lt;int&gt; { Value = 5 },
				}
			},
			new TreeNode&lt;int&gt; { Value = 4 },
		}
	},
	new TreeNode&lt;int&gt; { Value = -1 },
};
IEnumerable&lt;int&gt; values = root
	.SelectDepthFirst (x =&gt; x.Value, x =&gt; x.Children);
AssertAreSame (new[]{ 1, 2, 3, 5, 4, -1 }, values);
</code>
        </example>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="self" /> is <see langword="null" />.
          </para>
          <para>-or-</para>
          <para>
            <paramref name="childrenSelector" /> is <see langword="null" />.
          </para>
          <para>-or-</para>
          <para>
            <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SelectFromEach&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectFromEach&lt;T1,T2,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;T1&gt; self, System.Collections.Generic.IEnumerable&lt;T2&gt; source2, Func&lt;T1,T2,TResult&gt; selector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;T1,T2,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
        <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
        <typeparam name="TResult">
          The type of value returned by <paramref name="selector" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
        <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
        <param name="selector">
          A <see cref="T:System.Func{T1,T2,TResult}" /> which is used to
          transform the corresponding elements from lists
          <paramref name="self" /> and <paramref name="source2" />
          into the returned value.
        </param>
        <summary>
          Projects each corresponding element from multiple sequences into a 
          new form.
        </summary>
        <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          whose elements are the resulting of invoking
          <paramref name="selector" /> on each corresponding element of 
          <paramref name="self" /> and <paramref name="source2" />.
        </returns>
        <remarks>
          <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
            where each <typeparamref name="TResult" /> value is the result of
            applying <paramref name="selector" /> to an element from each of
            <paramref name="self" />, and <paramref name="source2" />
            with the same element index.
          </para>
          <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" /> and <paramref name="source2" />.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SelectFromEach2">List&lt;int&gt;  a = new List&lt;int&gt; {1, 2, 3, 4};
List&lt;char&gt; b = new List&lt;char&gt; {'a', 'b', 'c', 'd', 'e'};
var c = a.SelectFromEach (b, (x, y) =&gt; new { First = x, Second = y }).ToList ();
Assert.AreEqual (4, c.Count);
Assert.AreEqual (1,   c [0].First);
Assert.AreEqual ('a', c [0].Second);
Assert.AreEqual (2,   c [1].First);
Assert.AreEqual ('b', c [1].Second);
Assert.AreEqual (3,   c [2].First);
Assert.AreEqual ('c', c [2].Second);
Assert.AreEqual (4,   c [3].First);
Assert.AreEqual ('d', c [3].Second);
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" />, <paramref name="source2" />, or
          <paramref name="selector" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      </Docs>
    </Member>
    <Member MemberName="SelectFromEach&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectFromEach&lt;T1,T2,T3,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;T1&gt; self, System.Collections.Generic.IEnumerable&lt;T2&gt; source2, System.Collections.Generic.IEnumerable&lt;T3&gt; source3, Func&lt;T1,T2,T3,TResult&gt; selector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Collections.Generic.IEnumerable&lt;T3&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;T1,T2,T3,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
        <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
        <typeparam name="T3">
          The type of elements in the third list.
        </typeparam>
        <typeparam name="TResult">
          The type of value returned by <paramref name="selector" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
        <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
        <param name="source3">
          A <see cref="T:System.Collections.Generic.IEnumerable{T3}" />
          containing elements from the third list.
        </param>
        <param name="selector">
          A <see cref="T:System.Func{T1,T2,T3,TResult}" /> which is used to
          transform the corresponding elements from lists
          <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />
          into the returned value.
        </param>
        <summary>
          Projects each corresponding element from multiple sequences into a 
          new form.
        </summary>
        <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          whose elements are the resulting of invoking
          <paramref name="selector" /> on each corresponding element of 
          <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
        </returns>
        <remarks>
          <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
            where each <typeparamref name="TResult" /> value is the result of
            applying <paramref name="selector" /> to an element from each of
            <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />
            with the same element index.
          </para>
          <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SelectFromEach3">Assert.AreEqual ("123",
		new[]{1}.SelectFromEach (new[]{2}, new[]{3}, 
			(x,y,z) =&gt; x.ToString () + y.ToString () + z.ToString ()).Implode ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, or
          <paramref name="selector" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})" />
      </Docs>
    </Member>
    <Member MemberName="SelectFromEach&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectFromEach&lt;T1,T2,T3,T4,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;T1&gt; self, System.Collections.Generic.IEnumerable&lt;T2&gt; source2, System.Collections.Generic.IEnumerable&lt;T3&gt; source3, System.Collections.Generic.IEnumerable&lt;T4&gt; source4, Func&lt;T1,T2,T3,T4,TResult&gt; selector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Collections.Generic.IEnumerable&lt;T3&gt;" />
        <Parameter Name="source4" Type="System.Collections.Generic.IEnumerable&lt;T4&gt;" />
        <Parameter Name="selector" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
        <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
        <typeparam name="T3">
          The type of elements in the third list.
        </typeparam>
        <typeparam name="T4">
          The type of elements in the fourth list.
        </typeparam>
        <typeparam name="TResult">
          The type of value returned by <paramref name="selector" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
        <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
        <param name="source3">
          A <see cref="T:System.Collections.Generic.IEnumerable{T3}" />
          containing elements from the third list.
        </param>
        <param name="source4">
          A <see cref="T:System.Collections.Generic.IEnumerable{T4}" />
          containing elements from the fourth list.
        </param>
        <param name="selector">
          A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> which is used to
          transform the corresponding elements from lists
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />
          into the returned value.
        </param>
        <summary>
          Projects each corresponding element from multiple sequences into a 
          new form.
        </summary>
        <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          whose elements are the resulting of invoking
          <paramref name="selector" /> on each corresponding element of 
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
        </returns>
        <remarks>
          <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
            where each <typeparamref name="TResult" /> value is the result of
            applying <paramref name="selector" /> to an element from each of
            <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />
            with the same element index.
          </para>
          <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SelectFromEach4">Assert.AreEqual ("1234",
		new[]{1}.SelectFromEach (new[]{2}, new[]{3}, new[]{4},
			(w,x,y,z) =&gt; w.ToString () + x.ToString () + y.ToString () + z.ToString ()).Implode ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, <paramref name="source4" />, or
          <paramref name="selector" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})" />
      </Docs>
    </Member>
    <Member MemberName="SelectReverseAggregated&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Tuple&lt;TAccumulate,System.Collections.Generic.List&lt;TResult&gt;&gt; SelectReverseAggregated&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TAccumulate seed, Func&lt;TAccumulate,TSource,Cadenza.Tuple&lt;TAccumulate,TResult&gt;&gt; func);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Tuple&lt;TAccumulate,System.Collections.Generic.List&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,Cadenza.Tuple&lt;TAccumulate,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <typeparam name="TAccumulate">
          The type of the accumulator value.
        </typeparam>
        <typeparam name="TResult">
          The type of the return value.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to return the values of successive
          <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
          and
          <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
          calls from.
        </param>
        <param name="seed">
          The first <typeparamref name="TAccumulate" /> value to pass to
          <paramref name="func" />.
        </param>
        <param name="func">
          A
          <see cref="T:System.Func{TAccumulate,TSource,Cadenza.Tuple{TAccumulate,TResult}}" />
          which is applied against each element within <paramref name="self" />
          in reverse order and the current <paramref name="TAccumulate" />
          value (initially using <paramref name="seed" />), generating the
          next accumulated value and the (partial) result value.
        </param>
        <summary>
          Applies <paramref name="func" /> to each element within
          <paramref name="self" /> in reverse order, returning the final
          value of the accumulator and the list of intermediate values.
        </summary>
        <returns>
          A
          <see cref="T:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}" />
          which contains the final accumulated value in
          <see cref="P:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}.Item1" />
          and the list of intermediate results in
          <see cref="P:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}.Item2" />.
        </returns>
        <remarks>
          <para>This is Haskell's <c>mapAccumR</c>.</para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SelectReverseAggregated">IEnumerable&lt;int&gt; s = new []{1, 2, 3, 4};
Tuple&lt;int, List&lt;string&gt;&gt; r = s.SelectReverseAggregated (5,
		(a,b) =&gt; Tuple.Create (a-b, "s" + (a-b)));
Assert.AreEqual (-5, r.Item1);
Assert.IsTrue (new[]{
	"s1",
	"s-2",
	"s-4",
	"s-5",
}.SequenceEqual (r.Item2));

r = new int[]{}.SelectReverseAggregated (42,
		(a,b) =&gt; Tuple.Create (a-b, b.ToString ()));
Assert.AreEqual (42, r.Item1);
Assert.AreEqual (0, r.Item2.Count);
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="func" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceCompare&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompare&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, System.Collections.Generic.IEnumerable&lt;TSource&gt; list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="list" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to compare against <paramref name="list" />.
        </param>
        <param name="list">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to compare against <paramref name="self" />.
        </param>
        <summary>
          Compares the elements of two sequences by using the default
          comparer for their type.
        </summary>
        <returns>
          An <see cref="T:System.Int32" /> which is:
          <list type="table"><listheader><term>Value</term><description>Condition</description></listheader><item><term>Less than zero</term><description>
                The default comparer
                returned less than zero when comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                or <paramref name="self" /> had more elements than
                <paramref name="list" /> (and all elements in
                <paramref name="list" /> were equal to their corresponding
                elements within <paramref name="self" />).
              </description></item><item><term>Zero</term><description>
                The default comparer
                returned zero for all elements whe comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                and <paramref name="self" /> and <paramref name="list" />
                have the same number of elements.
              </description></item><item><term>Greater than zero</term><description>
                The default comparer
                returned greater than zero when comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                or <paramref name="list" /> had more elements than
                <paramref name="self" /> (and all elements in
                <paramref name="self" /> were equal to their corresponding
                elements within <paramref name="list" />).
              </description></item></list></returns>
        <remarks>
          <para>
            This is the
            <see cref="T:System.Collections.Generic.IComparer{TSource}" />
            analog to
            <see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />.
          </para>
          <para>
            This method enumerates <paramref name="self" /> and
            <paramref name="list" /> in parallel and compares corresponding
            elements by using the default
            <see cref="T:System.Collections.Generic.IComparer{TSource}" />.
            It returns non-zero the first time the default comparer
            returns non-zero.  If it runs out of elements, then it will return
            less than zero if <paramref name="self" /> still contains elements,
            will return zero if neither <paramref name="self" /> nor
            <paramref name="list" /> contain elements, and will return greater
            than zero if <paramref name="list" /> still contains elements.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SequenceCompare">Assert.AreEqual (0,
		new[]{1, 2}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (-1,
		new[]{1, 1}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (1,
		new[]{1, 3}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (-1,
		new[]{1, 2}.SequenceCompare (new[]{1}));
Assert.AreEqual (1,
		new[]{1}.SequenceCompare (new[]{1, 2}));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="list" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.SequenceCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})" />
      </Docs>
    </Member>
    <Member MemberName="SequenceCompare&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int SequenceCompare&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, System.Collections.Generic.IEnumerable&lt;TSource&gt; list, System.Collections.Generic.IComparer&lt;TSource&gt; comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="list" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to compare against <paramref name="list" />.
        </param>
        <param name="list">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to compare against <paramref name="self" />.
        </param>
        <param name="comparer">
          A <see cref="T:System.Collections.Generic.IComparer{TSource}" />
          which is used to compare elements from <paramref name="self" />
          and <paramref name="list" /> are to each other.  If
          <see langword="null" />, then
          <see cref="P:System.Collections.Generic.Comparer{TSource}.Default" />
          is used.
        </param>
        <summary>
          Compares the elements of two sequences by using a specified
          <see cref="T:System.Collections.Generic.IComparer{TSource}" />.
        </summary>
        <returns>
          An <see cref="T:System.Int32" /> which is:
          <list type="table"><listheader><term>Value</term><description>Condition</description></listheader><item><term>Less than zero</term><description><c><paramref name="comparer" />.Compare(x, y)</c>
                returned less than zero when comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                or <paramref name="self" /> had more elements than
                <paramref name="list" /> (and all elements in
                <paramref name="list" /> were equal to their corresponding
                elements within <paramref name="self" />).
              </description></item><item><term>Zero</term><description><c><paramref name="comparer" />.Compare(x, y)</c>
                returned zero for all elements whe comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                and <paramref name="self" /> and <paramref name="list" />
                have the same number of elements.
              </description></item><item><term>Greater than zero</term><description><c><paramref name="comparer" />.Compare(x, y)</c>
                returned greater than zero when comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                or <paramref name="list" /> had more elements than
                <paramref name="self" /> (and all elements in
                <paramref name="self" /> were equal to their corresponding
                elements within <paramref name="list" />).
              </description></item></list></returns>
        <remarks>
          <para>
            This is the
            <see cref="T:System.Collections.Generic.IComparer{TSource}" />
            analog to
            <see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />.
          </para>
          <para>
            This method enumerates <paramref name="self" /> and
            <paramref name="list" /> in parallel and compares corresponding
            elements by using the specified
            <see cref="T:System.Collections.Generic.IComparer{TSource}" />.
            It returns non-zero the first time <paramref name="comparer" />
            returns non-zero.  If it runs out of elements, then it will return
            less than zero if <paramref name="self" /> still contains elements,
            will return zero if neither <paramref name="self" /> nor
            <paramref name="list" /> contain elements, and will return greater
            than zero if <paramref name="list" /> still contains elements.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SequenceCompare">Assert.AreEqual (0,
		new[]{1, 2}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (-1,
		new[]{1, 1}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (1,
		new[]{1, 3}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (-1,
		new[]{1, 2}.SequenceCompare (new[]{1}));
Assert.AreEqual (1,
		new[]{1}.SequenceCompare (new[]{1, 2}));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="list" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Shuffle&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Shuffle&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove <paramref name="prefix" /> from.
        </param>
        <summary>
          Randomizes the ordering of items within <paramref name="self" />.
        </summary>
        <returns>
          A new <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          with the same number of elements as <paramref name="self" /> except
          that the elements returned may be in a different order.  The order of
          the elements returned is controlled by <paramref name="random" />.
        </returns>
        <remarks>
          <para>
            This is equivalent to calling <c>Shuffle(self, null)</c>.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Shuffle">IEnumerable&lt;int&gt; r = new[]{1,2,3,4,5}.Shuffle ();
Assert.AreEqual (5, r.Count());
Assert.IsTrue (r.Contains (1));
Assert.IsTrue (r.Contains (2));
Assert.IsTrue (r.Contains (3));
Assert.IsTrue (r.Contains (4));
Assert.IsTrue (r.Contains (5));

Assert.IsFalse (r.Contains (0));
Assert.IsFalse (r.Contains (6));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)" />
      </Docs>
    </Member>
    <Member MemberName="Shuffle&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Shuffle&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Random random);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="random" Type="System.Random" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove <paramref name="prefix" /> from.
        </param>
        <param name="random">
          A <see cref="T:System.Random" /> instance to get random numbers from.
        </param>
        <summary>
          Randomizes the ordering of items within <paramref name="self" />.
        </summary>
        <returns>
          A new <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          with the same number of elements as <paramref name="self" /> except
          that the elements returned may be in a different order.  The order of
          the elements returned is controlled by <paramref name="random" />.
        </returns>
        <remarks>
          <block subset="none" type="behaviors">
            Calls <see cref="M:System.Random.Next(System.Int32)" />
            once for each element within <paramref name="self" /> to partially
            determine the element's position within the returned sequence, then
            creates a new sequence based on the random element ordering.
          </block>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Shuffle">IEnumerable&lt;int&gt; r = new[]{1,2,3,4,5}.Shuffle ();
Assert.AreEqual (5, r.Count());
Assert.IsTrue (r.Contains (1));
Assert.IsTrue (r.Contains (2));
Assert.IsTrue (r.Contains (3));
Assert.IsTrue (r.Contains (4));
Assert.IsTrue (r.Contains (5));

Assert.IsFalse (r.Contains (0));
Assert.IsFalse (r.Contains (6));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SkipPrefix&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipPrefix&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, System.Collections.Generic.IEnumerable&lt;TSource&gt; prefix);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="prefix" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove <paramref name="prefix" /> from.
        </param>
        <param name="prefix">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove from the start of
          <paramref name="self" />.
        </param>
        <summary>
          Skips over <paramref name="prefix" />, returning the elements following
          <paramref name="prefix" />.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          if <paramref name="self" /> begins with <paramref name="prefix" />
          which contains the elements within <paramref name="self" /> following
          the sequence within <paramref name="prefix" />.
          If <paramref name="self" /> does not start with
          <paramref name="prefix" />, then <see langword="null" /> is returned.
        </returns>
        <remarks>
          <para>
            This is equivalent to calling <c>SkipPrefix(self, prefix, null).</c></para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SkipPrefix">Assert.AreEqual ("bar",
		"foobar".SkipPrefix ("foo").Implode ());
Assert.AreEqual ("",
		"foo".SkipPrefix ("foo").Implode ());
Assert.AreEqual (null,
		"barfoo".SkipPrefix ("foo"));
Assert.AreEqual (null,
		"barfoobaz".SkipPrefix ("foo"));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="prefix" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.SkipPrefix``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      </Docs>
    </Member>
    <Member MemberName="SkipPrefix&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipPrefix&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, System.Collections.Generic.IEnumerable&lt;TSource&gt; prefix, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="prefix" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove <paramref name="prefix" /> from.
        </param>
        <param name="prefix">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove from the start of
          <paramref name="self" />.
        </param>
        <param name="comparer">
          A <see cref="T:System.Collections.Generic.IEqualityComparer{TSource}" />
          to use to compare elements between the <paramref name="self" />
          and <paramref name="prefix" /> sequences.  If <see langword="null" />
          then
          <see cref="P:System.Collections.Generic.EqualityComparer{TSource}.Default" />
          is used.
        </param>
        <summary>
          Skips over <paramref name="prefix" />, returning the elements following
          <paramref name="prefix" />.
        </summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          if <paramref name="self" /> begins with <paramref name="prefix" />
          which contains the elements within <paramref name="self" /> following
          the sequence within <paramref name="prefix" />.
          If <paramref name="self" /> does not start with
          <paramref name="prefix" />, then <see langword="null" /> is returned.
        </returns>
        <remarks>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SkipPrefix">Assert.AreEqual ("bar",
		"foobar".SkipPrefix ("foo").Implode ());
Assert.AreEqual ("",
		"foo".SkipPrefix ("foo").Implode ());
Assert.AreEqual (null,
		"barfoo".SkipPrefix ("foo"));
Assert.AreEqual (null,
		"barfoobaz".SkipPrefix ("foo"));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="prefix" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Sort&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the sequence to sort by the default comparer.
        </param>
        <summary>Sorts the elements in the sequence <paramref name="self" /> using the default comparer.</summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the elements within <paramref name="self" /> sorted by
          the default comparer.
        </returns>
        <remarks>
          <para>
            Use this method instead of the
            <see cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
            method when you don't need to do anything "fancy," as this can
            result in faster execution.  For example, when sorting 20 million
            integers, the <c>Sort()</c> extension method can be upwards of 4x
            faster than the equivalent <c>OrderBy(e =&gt; e)</c> extension method call.
          </para>
          <block subset="none" type="behaviors">
            This method creates a
            <see cref="T:System.Collections.Generic.List{TSource} " />
            over <paramref name="self" />, invokes
            <see cref="M:System.Collections.Generic.List{TSource}.Sort" />
            and returns the list.
          </block>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.InvalidOperationException">
          The default comparer
          <see cref="P:System.Collections.Generic.Comparer{TSource}.Default" />
          cannot find ain implementation of the
          <see cref="T:System.Collections.Generic.IComparer{TSource}" />
          generic interface or the
          <see cref="T:System.Collections.IComparer" />
          interface for the type <typeparamref name="TSource" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Sort&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, System.Collections.Generic.IComparer&lt;TSource&gt; comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the sequence to sort by the default comparer.
        </param>
        <param name="comparer">
          A <see cref="T:System.Collections.Generic.IComparer{TSource} " />
          instance which is used to sort the elements within
          <paramref name="self" />.
          If <see langword="null" />, then
          <see cref="P:System.Collections.Generic.Comparer{TSource}.Default" />
          is used.
        </param>
        <summary>Sorts the elements in the sequence <paramref name="self" /> using the specified comparer.</summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the elements within <paramref name="self" /> sorted by
          the default comparer.
        </returns>
        <remarks>
          <para>
            Use this method instead of the
            <see cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
            method when you don't need to do anything "fancy," as this can
            result in faster execution.  For example, when sorting 20 million
            integers, the <c>Sort()</c> extension method can be upwards of 4x
            faster than the equivalent <c>OrderBy(e =&gt; e)</c> extension method call.
          </para>
          <block subset="none" type="behaviors">
            This method creates a
            <see cref="T:System.Collections.Generic.List{TSource} " />
            over <paramref name="self" />, invokes
            <see cref="M:System.Collections.Generic.List{TSource}.Sort(System.Collections.Generic.IComparer{`0})" />
            and returns the list.
          </block>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />
          and the default comparer
          <see cref="P:System.Collections.Generic.Comparer{TSource}.Default" />
          cannot find ain implementation of the
          <see cref="T:System.Collections.Generic.IComparer{TSource}" />
          generic interface or the
          <see cref="T:System.Collections.IComparer" />
          interface for the type <typeparamref name="TSource" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Sort&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Comparison&lt;TSource&gt; comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparison" Type="System.Comparison&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the sequence to sort by the default comparer.
        </param>
        <param name="comparison">
          A <see cref="T:System.Comparison{TSource} " />
          instance which is used to sort the elements within
          <paramref name="self" />.
        </param>
        <summary>Sorts the elements in the sequence <paramref name="self" /> using the specified comparer.</summary>
        <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the elements within <paramref name="self" /> sorted by
          the default comparer.
        </returns>
        <remarks>
          <para>
            Use this method instead of the
            <see cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
            method when you don't need to do anything "fancy," as this can
            result in faster execution.  For example, when sorting 20 million
            integers, the <c>Sort()</c> extension method can be upwards of 4x
            faster than the equivalent <c>OrderBy(e =&gt; e)</c> extension method call.
          </para>
          <block subset="none" type="behaviors">
            This method creates a
            <see cref="T:System.Collections.Generic.List{TSource} " />
            over <paramref name="self" />, invokes
            <see cref="M:System.Collections.Generic.List{TSource}.Sort(System.Comparer{`0})" />
            and returns the list.
          </block>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="comparison" />
          is <see langword="null" />.
        </exception>
        <exception cref="T:System.ArgumentException">
          The implementation of <paramref name="comparison" /> caused an error
          during the sort.  For example, <paramref name="comparison" /> might
          not return <c>0</c> when comparing an item with itself.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SortNatural">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; SortNatural (this System.Collections.Generic.IEnumerable&lt;string&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the elements to sort.
        </param>
        <summary>
          Returns a new 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which contains the elements within <paramref name="self" /> sorted 
          using the
          <see cref="F:Cadenza.NaturalStringComparer.Default" /> comparer.
        </summary>
        <returns>
          A new 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which contains the elements within <paramref name="self" /> sorted 
          using the
          <see cref="F:Cadenza.NaturalStringComparer.Default" /> comparer.
        </returns>
        <remarks>
          <para>
            This method does not modify <paramref name="self" />.
          </para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Span&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; Span&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,bool&gt; predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to create a span of.
        </param>
        <param name="predicate">
          A <see cref="T:System.Func{TSource,System.Boolean}" /> which
          controls which elements from <paramref name="self" /> are present
          within the returned 
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._1" />.
          sequence.
        </param>
        <summary>
          Creates a 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}" />
          of the contiguous elements at the start of <paramref name="self" /> 
          which satisfy <paramref name="predicate" />.
        </summary>
        <returns>
          Creates a 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}" />;
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._1" />
          contains the (possibly empty) sequence of elements at the start of
          <paramref name="self" /> which satisfy <paramref name="predicate" />,
          and
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._2" />
          contains all remaining elements from <paramref name="self" />.
        </returns>
        <remarks>
          <para>
            This is equivalent to: 
            <c>Tuple.Create (self.TakeWhile (predicate), 
            self.SkipWhile (predicate));</c>.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Span">Assert.AreEqual ("12|341234",
		new[]{1,2,3,4,1,2,3,4}.Span (e =&gt; e &lt; 3)
		.Aggregate ((x, y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("123|",
		new[]{1,2,3}.Span (e =&gt; e &lt; 9)
		.Aggregate ((x, y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("|123",
		new[]{1,2,3}.Span (e =&gt; e &lt; 0)
		.Aggregate ((x, y) =&gt; x.Implode () + "|" + y.Implode ()));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="predicate" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SplitAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; SplitAt&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, int firstLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="firstLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to split.
        </param>
        <param name="firstLength">
          The number of elements to return in the first created sequence.
        </param>
        <summary>
          Splits <paramref name="self" /> at <paramref name="firstLength" />,
          creating a 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}" />.
        </summary>
        <returns>
          A 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}" />,
          where 
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._1" />
          contains the first <paramref name="firstLength" /> elements from
          <paramref name="self" />, and 
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._2" />
          contains the remaining elements from the sequence.
        </returns>
        <remarks>
          <para>
            This is equivalent to 
            <c>Tuple.Create (self.Take (firstLength), 
            self.Skip (firstLength));</c>.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#SplitAt">Assert.AreEqual ("Hello |World!",
		"Hello World!".SplitAt (6)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("123|45",
		new[]{1,2,3,4,5}.SplitAt (3)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("1|23",
		new[]{1,2,3}.SplitAt (1)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("123|",
		new[]{1,2,3}.SplitAt (3)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("123|",
		new[]{1,2,3}.SplitAt (4)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("|123",
		new[]{1,2,3}.SplitAt (0)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="firstLength" /> is negative.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Subsets&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; Subsets&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to create subsets from.
        </param>
        <summary>
          Creates all subsets of a given input sequence.
        </summary>
        <returns>
          An unordered <see cref="T:System.Collections.IEnumerable{System.Collections.IEnumerable{TSource}}" />
          that contains all subsets of <paramref name="source" /> including the set <paramref name="self" /> itself.
        </returns>
        <remarks>
          <para>This creates all subsets from the sequence <paramref name="self" />.</para>
          <para>Sequences greater than 63 items are not supported and will throw a <see cref="T:System.InvalidOperationException" /> when you try to enumerate the results.</para>
          <code>Given the input sequence, [a, b, c] the result would be:
[a]
[b]
[a,b]
[c]
[a,c]
[b,c]
[a,b,c]</code>
          <para>
            Note: This method does not remove duplicates from <paramref name="self" />. If <paramref name="self" /> may contain duplicates and you want true subsets use
            <see cref="T:System.Linq.Enumerable.Distinct{TSource}" /> first, e.g. <c>source.Distinct().Subsets()</c>.
          </para>
          <para>
            Note: This method does not guarantee any order to the results so future implementations may return the results in a different order.
          </para>
          <para>
            Note: This keep the input sizes small, as the result set will contain <c>(n ^ 2) - 1</c> results, eg for 20 items there are 1,048,575 subsets.
          </para>
        </remarks>
        <example>
          <code lang="C#"><![CDATA[List<string> source = new List<string> { "a", "b", "c" };
IEnumerable<IEnumerable<string>> results = source.Subsets ();

foreach (IEnumerable<string> subset in results) {

  foreach (string value in subset) {
    Console.Write (value);
    Console.Write (" ");
  }

  Console.WriteLine ();
}
]]></code>
          <code lang="VB">Dim source As New List (Of String) (New String () { "a", "b", "c" })
Dim results As IEnumerable (Of IEnumerable (Of String)) = source.Subsets ()

For Each subset As IEnumerable (Of String) In results

  For Each value As String In subset
    Console.Write (value)
    Console.Write (" ")
  Next
  
  Console.WriteLine ()
Next
</code>
        </example>
        <exception cref="T:System.ArgumentNullException">
          If <paramref name="self" /> is null (Nothing in VB).
        </exception>
        <exception cref="T:System.InvalidOperationException">
          If <paramref name="self" /> contains more than 63 items. Important, this will only be thrown when you start enumerating the results.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Subsets&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; Subsets&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,bool&gt; predicate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" /> containing the sequence to create subsets from.
        </param>
        <param name="predicate">
          A <see cref="T:System.Func{TSource,System.Boolean}" /> used to filter .
        </param>
        <summary>
          Creates all subsets that match <paramref name="predicate" />.
        </summary>
        <returns>
          An unordered <see cref="T:System.Collections.IEnumerable{System.Collections.IEnumerable{TSource}}" /> that contains
          all subsets of <paramref name="source" /> including the set <paramref name="self" /> itself, excluding any sets and
          all their supersets that did not match the <paramref name="predicate" />.
        </returns>
        <remarks>
          <para>
            This creates all subsets from the sequence <paramref name="self" />, excluding any sets and their supersets that were
            filtered out by <paramref name="predicate" />.
          </para>
          <code>Given the input sequence, [a, b, c] and filtering out anything containing the subset [a, b] the result would be:
[a]
[b]
[c]
[a,c]
[b,c]</code>
          <para>
            Note: This method does not remove duplicates from <paramref name="self" />. If <paramref name="self" /> may contain
            duplicates and you want true subsets use <see cref="T:System.Linq.Enumerable.Distinct{TSource}" /> first, e.g.
            <c>source.Distinct().Subsets(predicate)</c>.
          </para>
          <para>
            Note: This method does not guarantee any order to the results so future implementations may return the results in a different order.
          </para>
        </remarks>
        <example>
          <code lang="C#"><![CDATA[List<string> source = new List<string> { "a", "b", "c" };
IEnumerable<IEnumerable<string>> results = source.Subsets (x => !(x.Contains ("a") && x.Contains ("b")));

foreach (IEnumerable<string> subset in results) {

  foreach (string value in subset) {
    Console.Write (value);
    Console.Write (" ");
  }

  Console.WriteLine ();
}
]]></code>
          <code lang="VB">Dim source As New List (Of String) (New String () { "a", "b", "c" })
Dim results As IEnumerable (Of IEnumerable (Of String)) = source.Subsets (Function (x) Not (x.Contains ("a") AndAlso x.Contains ("b")))

For Each subset As IEnumerable (Of String) In results

  For Each value As String In subset
    Console.Write (value)
    Console.Write (" ")
  Next

  Console.WriteLine ()
Next
</code>
        </example>
        <exception cref="T:System.ArgumentNullException">
          If <paramref name="self" /> is null (Nothing in VB).
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Tokens&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Tokens&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; accumulate, Func&lt;TAccumulate,Cadenza.Tuple&lt;TResult,TAccumulate&gt;&gt; resultSelector, Func&lt;TAccumulate,TSource,bool&gt;[] categories);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="accumulate" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,Cadenza.Tuple&lt;TResult,TAccumulate&gt;&gt;" />
        <Parameter Name="categories" Type="System.Func&lt;TAccumulate,TSource,System.Boolean&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of elements within <paramref name="self" />.
        </typeparam>
        <typeparam name="TAccumulate">
          The type of the accumulator value.
        </typeparam>
        <typeparam name="TResult">
          The type of the resulting sequence of values.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the values to aggregate and convert.
        </param>
        <param name="seed">
          The initial accumulator value.
        </param>
        <param name="accumulate">
          A <see cref="T:System.Func{TAccumulate,TSource,TAccumulate}" />
          which is used to accumulate values from <paramref name="self" />
          into one of the values returned.
        </param>
        <param name="resultSelector">
          A <see cref="T:System.Func{TAccumulate,Cadenza.Tuple{TResult,TAccumulate}}" />
          which is used to do two things: convert the accumulated value into a
          return value, and reset the accumulator.
          The <see cref="P:Cadenza.Tuple{TResult,TAccumulate}.Item1" /> property
          contains the value to return, while
          the <see cref="P:Cadenza.Tuple{TResult,TAccumulate}.Item2" /> property
          contains the new accumulator seed value.
        </param>
        <param name="categories">
          A <see cref="T:System.Func{TAccumulate,TSource,System.Boolean}" />
          array which contains "categories." A "category" is how
          <c>Tokens</c> knows when to call <paramref name="accumulate" />
          or <paramref name="resultSelector" />.
          If a category returns <see langword="true" /> on an element
          from <paramref name="self" />, then
          <paramref name="accumulate" /> will be invoked; otherwise,
          <paramref name="resultSelector" /> is invoked.
        </param>
        <summary>
          A simple lexer to convert an
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          into a
          <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />,
          where the resulting sequence may have a different number of elements
          than the source sequence.
        </summary>
        <returns>
          An <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the resulting "tokens" that
          <paramref name="accumulator" /> and
          <paramref name="resultSelector" /> produced.
        </returns>
        <remarks>
          <para>
            This is either a very simple lexer, or the unholy combination of
            <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
            and
            <see cref="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />.
            You decide.
          </para>
          <para>
            <c>Tokens</c> allows converting the source sequence
            <paramref name="self" /> of length <c>N</c> into a
            resulting sequence of length <c>M</c>, where <c>N</c>
            can differ from <c>M</c>, and <c>M</c> can be greater than one.
            (This differs from <c>Enumerable.Select()</c>, where the
            resulting sequence has the same number of elements as the source
            sequence, and it differs from <c>Enumerable.Aggregate()</c>,
            where only a single value is returned.)
          </para>
          <block subset="none" type="behaviors">
            <para>
              For each element in <paramref name="self" />, get the "category index"
              for the element.  The "category index" is the first index into the
              <paramref name="categories" /> array for which a
              <see cref="T:System.Func{TAccumulate,TSource,System.Boolean}" />
              returns <see langword="true" />.  Then one of three things happens:
            </para>
            <list type="number">
              <item>
                <term>
                If the category index is the same as the previous element's
                category index, then <paramref name="accumulate" /> is invoked
                with the current accumulated value and the current element.
              </term>
              </item>
              <item>
                <term>
                If the category index differs from the previous element's
                category index, then <paramref name="resultSelector" />
                is invoked to obtain a
                <see cref="T:Cadenza.Tuple{TResult,TAccumulate}" />.
                The
                <see cref="P:Cadenza.Tuple{TResult,TAccumulate}.Item1" />
                value is yielded from <c>Tokens</c> as one of the return
                values, and
                <see cref="P:Cadenza.Tuple{TResult,TAccumulate}.Item2" />
                is used as the new seed value for the next
                <paramref name="accumulate" /> call.
              </term>
              </item>
              <item>
                <term>
                If no matching category is found (i.e. all entries in
                <paramref name="categories" />
                return <see langword="false" />),
                then the element is ignored.
              </term>
              </item>
            </list>
            <para>
              This use of "categories" and matching indexes allows for
              implementing precedence rules in a straightforward manner:
              if the category index differs, the accumulated token
              must have a different precedence, and thus should be returned
              and the accumulation process restarted.
            </para>
          </block>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Tokens">// Turn a sequence of numbers into a new sequence of numbers
// for which the sum is less than 10.
IEnumerable&lt;int&gt;  numbers         = new[]{1, 1, 3, 5, 8, 13};
IEnumerable&lt;int&gt;  sumsLessThan10  = numbers.Tokens (0,
		// accumulate: add the values together.
		// p=previous value, c=current value
		(p, c) =&gt; p + c,
		// resultSelector: return the current sum and reset count to 0.
		r =&gt; Tuple.Create (r, 0),
		// category: sum is less than 10.
		(p, c) =&gt; p + c &lt; 10
);
// Notice that the input value of 13 is missing, as it didn't match
// any category.
Assert.IsTrue (new[]{5, 5, 8}.SequenceEqual (sumsLessThan10));

// More "traditional" lexing, with categories as precedence rules
string expression = " function(value1+value2)  ";
IEnumerable&lt;string&gt; exprTokens = expression.Tokens ("",
		// accumulate: concatenate the characters together
		(p, c) =&gt; p + c,
		r =&gt; Tuple.Create (r, ""),
		// category: identifiers: [A-Za-z_][A-Za-z0-9_]*
		(p, c) =&gt; p.Length == 0
			? char.IsLetter (c) || c == '_'
			: char.IsLetterOrDigit (c) || c == '_',
		// category: arithmetic operators
		(p, c) =&gt; c == '+' || c == '-' || c == '*' || c == '/',
		// category: grouping
		(p, c) =&gt; c == '(' || c == ')'
);
// Notice that all whitespace has been removed
Assert.IsTrue (
		new[]{"function", "(", "value1", "+", "value2", ")"}
		.SequenceEqual (exprTokens));
</code>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="categories" /> contains no elements.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" />, <paramref name="accumulate" />,
          <paramref name="resultSelector" />, or
          <paramref name="categories" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;System.Collections.Generic.List&lt;TSource&gt;&gt; ToList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;System.Collections.Generic.List&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
        <param name="self">
          A 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          to convert into a 
          <see cref="T:System.Collections.Generic.List{System.Collections.Generic.List{TSource}}" /></param>
        <summary>
          Creates a 
          <see cref="T:System.Collections.Generic.List{System.Collections.Generic.List{TSource}}" />
          with the same ordering and values as <paramref name="self" />.
        </summary>
        <returns>
          A 
          <see cref="T:System.Collections.Generic.List{System.Collections.Generic.List{TSource}}" />
          with the same ordering and values as <paramref name="self" />.
        </returns>
        <remarks>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#ToList">int[][] a = new int[][]{
	new int[]{1, 2, 3},
	new int[]{4, 5, 6},
};
IEnumerable&lt;IEnumerable&lt;int&gt;&gt; b = a;
List&lt;List&lt;int&gt;&gt; c = b.ToList ();
Assert.AreEqual (a.Length, c.Count);
Assert.AreEqual (a [0].Length, c [0].Count);
Assert.AreEqual (a [1].Length, c [1].Count);
Assert.AreEqual (a [0][0], c [0][0]);
Assert.AreEqual (a [0][1], c [0][1]);
Assert.AreEqual (a [0][2], c [0][2]);
Assert.AreEqual (a [1][0], c [1][0]);
Assert.AreEqual (a [1][1], c [1][1]);
Assert.AreEqual (a [1][2], c [1][2]);
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToReadOnlyDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Collections.ReadOnlyDictionary&lt;TKey,TSource&gt; ToReadOnlyDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Collections.ReadOnlyDictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">The type of the elements in <paramref name="self" />.</typeparam>
        <typeparam name="TKey">
          The type of the key returned by <paramref name="keySelector" />.
        </typeparam>
        <param name="self">
          An
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          to create a 
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TValue}" />
          from.
        </param>
        <param name="keySelector">
          A <see cref="T:System.Func{TSource,TKey}" /> used to extract a key 
          from each element in <paramref name="self" />.
        </param>
        <summary>
          Creates a 
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TSource}" />
          from an
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          according to a specified key selector and value selector delegate.
        </summary>
        <returns>
          A
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TSource}" />
          which contains the key/value values from <paramref name="self" />.
        </returns>
        <remarks>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="self" />, <paramref name="keySelector" />, or
            <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
          <para>-or-</para>
          <para>
            <paramref name="keySelector" /> produces a key that is
            <see langword="null" />.
          </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToReadOnlyDictionary&lt;TSource,TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Collections.ReadOnlyDictionary&lt;TKey,TValue&gt; ToReadOnlyDictionary&lt;TSource,TKey,TValue&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TValue&gt; valueSelector);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Collections.ReadOnlyDictionary&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="valueSelector" Type="System.Func&lt;TSource,TValue&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">The type of the elements in <paramref name="self" />.</typeparam>
        <typeparam name="TKey">
          The type of the key returned by <paramref name="keySelector" />.
        </typeparam>
        <typeparam name="TValue">
          The type of the value returned by <paramref name="valueSelector" />.
        </typeparam>
        <param name="self">
          An
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          to create a 
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TValue}" />
          from.
        </param>
        <param name="keySelector">
          A <see cref="T:System.Func{TSource,TKey}" /> used to extract a key 
          from each element in <paramref name="self" />.
        </param>
        <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TValue}" /> used to extract a 
          value from each element in <paramref name="self" />.
        </param>
        <summary>
          Creates a 
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TValue}" />
          from an
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          according to a specified key selector and value selector delegate.
        </summary>
        <returns>
          A
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TValue}" />
          which contains the key/value values from <paramref name="self" />.
        </returns>
        <remarks>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="self" />, <paramref name="keySelector" />, or
            <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
          <para>-or-</para>
          <para>
            <paramref name="keySelector" /> produces a key that is
            <see langword="null" />.
          </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToTuple">
      <MemberSignature Language="C#" Value="public static object ToTuple (this System.Collections.IEnumerable self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <param name="self">
          A <see cref="T:System.Collections.IEnumerable" /> containing the
          values to insert into a Tuple.
        </param>
        <summary>
          Creates a <c>Tuple</c> from a sequence.
        </summary>
        <returns>
          <para>
            A <see cref="T:System.Object" />
            backed by a <c>Tuple</c> containing the values within the sequence 
            <paramref name="self" />.
          </para>
          <para>
            No specific tuple is returned, as it depends upon the number of
            elements within <paramref name="self" />, thus a cast is necessary
            to the appropriate <c>Tuple</c> type to use it as a Tuple.
          </para>
        </returns>
        <remarks>
          <para>
            Converts a sequence into a <c>Tuple</c>.  The specific tuple
            returned is dependent upon <paramref name="self" />.
            <paramref name="self" /> must have between 1 and 
            <see cref="P:Cadenza.Tuple.MaxValues" /> elements, inclusive,
            otherwise a <see cref="T:System.NotSupportedException" /> is
            thrown.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#ToTuple">IEnumerable&lt;object&gt; s = new object[]{1, '2', 3L, "4"};
object tl = s.ToTuple ();
Assert.AreEqual (typeof(Tuple&lt;int, char, long, string&gt;), tl.GetType());

var t = (Tuple&lt;int, char, long, string&gt;) tl;
Assert.AreEqual (1,   t.Item1);
Assert.AreEqual ('2', t.Item2);
Assert.AreEqual (3L,  t.Item3);
Assert.AreEqual ("4", t.Item4);
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.NotSupportedException">
          The number of elements within <paramref name="self" /> exceeds
          <see cref="P:Cadenza.Tuple.MaxValues" />, and thus no tuple type
          exists to contain all the elements within <paramref name="self" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToValueReader">
      <MemberSignature Language="C#" Value="public static Cadenza.IO.TextValueReader ToValueReader (this System.Collections.Generic.IEnumerable&lt;string&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.IO.TextValueReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing elements to read values from.
        </param>
        <summary>
          Creates a <see cref="T:Cadenza.IO.TextValueReader" />
          which will extract values from an 
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />.
        </summary>
        <returns>
          A <see cref="T:Cadenza.IO.TextValueReader" />
          which will extract values from an 
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />.
        </returns>
        <remarks>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
      </Docs>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="ToValueReader&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.IO.EnumerableValueReader&lt;TSource&gt; ToValueReader&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.IO.EnumerableValueReader&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
        <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing elements to read values from.
        </param>
        <summary>
          Creates a <see cref="T:Cadenza.IO.EnumerableValueReader" />
          which will extract values from an 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />.
        </summary>
        <returns>
          A <see cref="T:Cadenza.IO.EnumerableValueReader" />
          which will extract values from an 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />.
        </returns>
        <remarks>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
      </Docs>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
    </Member>
    <Member MemberName="TrailingSegments&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; TrailingSegments&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence for which to return the trailing segments.
        </param>
        <summary>
          Creates a 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing all final segments of <paramref name="self" />,
          longest first.
        </summary>
        <returns>
          A 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing all final segments of <paramref name="self" />,
          longest first.
        </returns>
        <remarks>
          <para>
            A "final segment" is the list of <typeparamref name="TSource" />
            values following the "current" index, in which the current index
            starts at the start of <paramref name="self" /> and increments
            until the end of <paramref name="self" />.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#TrailingSegments">IEnumerable&lt;IEnumerable&lt;char&gt;&gt; e = "abc".TrailingSegments ();
var l = e.ToList ();
Assert.AreEqual (4, l.Count);
AssertAreSame (new[]{'a', 'b', 'c'},  l [0]);
AssertAreSame (new[]{'a', 'b'},       l [1]);
AssertAreSame (new[]{'a'},            l [2]);
AssertAreSame (new char[]{},          l [3]);
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.InitialSegments``1(System.Collections.Generic.IEnumerable{``0})" />
      </Docs>
    </Member>
    <Member MemberName="Transpose&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; Transpose&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.IEnumerable&lt;TSource&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">
          The type of element to return.
        </typeparam>
        <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing rows and columns to transpose.
        </param>
        <summary>
          Transposes <paramref name="self" />, so that rows become columns and
          columns become rows in the returned 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />.
        </summary>
        <returns>
          A 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />,
          in which columns and rows are transposed.
        </returns>
        <remarks>
          <para>
            If each row has a different number of elements, then the returned 
            <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />.
            will have as many rows as the longest number of columns within
            <paramref name="self" />, and any rows with fewer than the
            maximum number of input columns are "skipped" when an input column
            index exceeds the length of that row.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Transpose">IEnumerable&lt;IEnumerable&lt;int&gt;&gt; a = new int[][]{
	new int[]{1, 2, 3},
	new int[]{4, 5, 6},
};
IEnumerable&lt;IEnumerable&lt;int&gt;&gt; b = a.Transpose ();
List&lt;List&lt;int&gt;&gt; c = b.ToList ();
Assert.AreEqual (3, c.Count);
Assert.AreEqual (2, c [0].Count);
Assert.AreEqual (2, c [1].Count);
Assert.AreEqual (2, c [2].Count);
Assert.AreEqual (1, c [0][0]);
Assert.AreEqual (4, c [0][1]);
Assert.AreEqual (2, c [1][0]);
Assert.AreEqual (5, c [1][1]);
Assert.AreEqual (3, c [2][0]);
Assert.AreEqual (6, c [2][1]);

// Test non-"rectangular" array
a = new int[][]{
	new int[]{1, 2},
	new int[]{3},
	new int[]{4, 5},
};
b = a.Transpose ();
Assert.AreEqual (2, b.Count ());
Assert.IsTrue (new[]{1, 3, 4}.SequenceEqual (b.ElementAt (0)));
Assert.IsTrue (new[]{2, 5}.SequenceEqual (b.ElementAt (1)));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetFirst&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetFirst&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, out TSource first);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="first" Type="TSource&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">The type of the elements in <paramref name="self" />.</typeparam>
        <param name="self">
          An <see cref="T:System.Collections.Generic.IEnumerable{TSource}" /> 
          containing the sequence of elements to extract the first element from.
        </param>
        <param name="first">
          When this method returns, contains a <typeparamref name="TSource" /> 
          which contains either the first element within <paramref name="self" />
          (if the return value is <see langword="true" />), or will 
          contain <c>default(<typeparamref name="TSource" />)</c>.
        </param>
        <summary>Attempts to obtain the first element in the sequence.</summary>
        <returns>
          <see langword="true" /> if <paramref name="self" /> contains elements
          and <paramref name="first" /> contains the value of the first element; 
          otherwise, <see langword="false" />.
        </returns>
        <remarks>
          <block subset="none" type="note">
            Use this method instead of 
            <see cref="M:System.Linq.Enumerable.FirstOrDefault`1(System.Collections.Generic.IEnumerable{``0})" />
            when one of the elements in the sequence may be 
            <c>default(<typeparamref name="TSource" />)</c>, thus making it 
            impossible to tell if 
            <c>default(<typeparamref name="TSource" />)</c>, was returned 
            because no matching element was found or because 
            <c>default(<typeparamref name="TSource" />)</c>, was the matching
            element).
          </block>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#TryGetFirst">var seq = new int[]{0, 1, 2};
int first;

Assert.IsTrue (seq.TryGetFirst (out first));
Assert.IsTrue (0 == first);

seq = new int[]{};
Assert.IsFalse (seq.TryGetFirst (out first));
Assert.IsTrue (0 == first);
</code>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetFirst&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool TryGetFirst&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; self, Func&lt;TSource,bool&gt; predicate, out TSource first);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
        <Parameter Name="first" Type="TSource&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">The type of the elements in <paramref name="self" />.</typeparam>
        <param name="self">
          An <see cref="T:System.Collections.Generic.IEnumerable{TSource}" /> 
          containing the sequence of elements to extract the first element from.
        </param>
        <param name="predicate">
          A <see cref="T:System.Func{TSource,System.Boolean}" /> which is tested
          against each element within <paramref name="self" />.
        </param>
        <param name="first">
          When this method returns, contains a <typeparamref name="TSource" /> 
          which contains either the first element for which 
          <paramref name="predicate" /> returned <see langword="true" />
          (if the return value is <see langword="true" />), or will 
          contain <c>default(<typeparamref name="TSource" />)</c>.
        </param>
        <summary>Attempts to obtain the first element in the sequence that satisfies the specified condition.</summary>
        <returns>
          <see langword="true" /> if <paramref name="self" /> contains elements
          and <paramref name="predicate" /> returned <see langword="true" />
          for one of those elements and <paramref name="first" /> contains
          the value of the first matching value; otherwise, <see langword="false" />.
        </returns>
        <remarks>
          <block subset="none" type="note">
            Use this method instead of 
            <see cref="M:System.Linq.Enumerable.FirstOrDefault`1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
            when one of the elements in the sequence may be 
            <c>default(<typeparamref name="TSource" />)</c>, thus making it 
            impossible to tell if 
            <c>default(<typeparamref name="TSource" />)</c>, was returned 
            because no matching element was found or because 
            <c>default(<typeparamref name="TSource" />)</c>, was the matching
            element).
          </block>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#TryGetFirst2">var seq = new int[]{0, 1, 2};
int first;

Assert.IsTrue (seq.TryGetFirst (v =&gt; v.IsOdd (), out first));
Assert.IsTrue (1 == first);

Assert.IsTrue (seq.TryGetFirst (v =&gt; v.IsEven (), out first));
Assert.IsTrue (0 == first);

Assert.IsFalse (seq.TryGetFirst (v =&gt; v == 5, out first));
Assert.IsTrue (0 == first);
</code>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unzip&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;T1&gt;,System.Collections.Generic.IEnumerable&lt;T2&gt;&gt; Unzip&lt;T1,T2&gt; (this System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2&gt;&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;T1&gt;,System.Collections.Generic.IEnumerable&lt;T2&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
          The type of the first sequence to return.
        </typeparam>
        <typeparam name="T2">
          The type of the second sequence to return.
        </typeparam>
        <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          to split up into separate lists.
        </param>
        <summary>
          Converts an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          into a tuple of lists, one for each 
          <see cref="T:Cadenza.Tuple{T1,T2}" />
          element.
        </summary>
        <returns>
          An 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{T1},System.Collections.Generic.IEnumerable{T2}}" />
          containing the appropriate elements from each 
          <see cref="T:Cadenza.Tuple{T1,T2}" />.
        </returns>
        <remarks>
          <para>
            This is analogous to undoing a <c>Zip</c> operation.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Unzip2">Assert.AreEqual ("1,2|3,4",
		new[]{1,2}.Zip (new[]{3,4,5}).Unzip ()
		.Aggregate ((a, b) =&gt; a.Implode (",") + "|" + b.Implode (",")));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      </Docs>
    </Member>
    <Member MemberName="Unzip&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;T1&gt;,System.Collections.Generic.IEnumerable&lt;T2&gt;,System.Collections.Generic.IEnumerable&lt;T3&gt;&gt; Unzip&lt;T1,T2,T3&gt; (this System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2,T3&gt;&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;T1&gt;,System.Collections.Generic.IEnumerable&lt;T2&gt;,System.Collections.Generic.IEnumerable&lt;T3&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2,T3&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
          The type of the first sequence to return.
        </typeparam>
        <typeparam name="T2">
          The type of the second sequence to return.
        </typeparam>
        <typeparam name="T3">
          The type of the third sequence to return.
        </typeparam>
        <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3}}" />
          to split up into separate lists.
        </param>
        <summary>
          Converts an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3}}" />
          into a tuple of lists, one for each 
          <see cref="T:Cadenza.Tuple{T1,T2,T3}" />
          element.
        </summary>
        <returns>
          An 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{T1},System.Collections.Generic.IEnumerable{T2},System.Collections.Generic.IEnumerable{T3}}" />
          containing the appropriate elements from each 
          <see cref="T:Cadenza.Tuple{T1,T2,T3}" />.
        </returns>
        <remarks>
          <para>
            This is analogous to undoing a <c>Zip</c> operation.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Unzip3">Assert.AreEqual ("1,2|3,4|5,6",
		new[]{1,2}.Zip (new[]{3,4,5}, new[]{5,6}).Unzip ()
		.Aggregate ((a, b, c) =&gt; a.Implode (",") + "|" + b.Implode (",") + "|" + c.Implode (",")));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})" />
      </Docs>
    </Member>
    <Member MemberName="Unzip&lt;T1,T2,T3,T4&gt;">
      <MemberSignature Language="C#" Value="public static Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;T1&gt;,System.Collections.Generic.IEnumerable&lt;T2&gt;,System.Collections.Generic.IEnumerable&lt;T3&gt;,System.Collections.Generic.IEnumerable&lt;T4&gt;&gt; Unzip&lt;T1,T2,T3,T4&gt; (this System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2,T3,T4&gt;&gt; self);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Cadenza.Tuple&lt;System.Collections.Generic.IEnumerable&lt;T1&gt;,System.Collections.Generic.IEnumerable&lt;T2&gt;,System.Collections.Generic.IEnumerable&lt;T3&gt;,System.Collections.Generic.IEnumerable&lt;T4&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2,T3,T4&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
          The type of the first sequence to return.
        </typeparam>
        <typeparam name="T2">
          The type of the second sequence to return.
        </typeparam>
        <typeparam name="T3">
          The type of the third sequence to return.
        </typeparam>
        <typeparam name="T4">
          The type of the fourth sequence to return.
        </typeparam>
        <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3,T4}}" />
          to split up into separate lists.
        </param>
        <summary>
          Converts an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3,T4}}" />
          into a tuple of lists, one for each 
          <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" />
          element.
        </summary>
        <returns>
          An 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{T1},System.Collections.Generic.IEnumerable{T2},System.Collections.Generic.IEnumerable{T3},System.Collections.Generic.IEnumerable{T4}}" />
          containing the appropriate elements from each 
          <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" />.
        </returns>
        <remarks>
          <para>
            This is analogous to undoing a <c>Zip</c> operation.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Unzip4">Assert.AreEqual ("1,2|3,4|5,6|7,8",
		new[]{1,2}.Zip (new[]{3,4,5,6}, new[]{5,6,7}, new[]{7,8}).Unzip ()
		.Aggregate ((a, b, c, d) =&gt; a.Implode (",") + "|" + b.Implode (",") + "|" + c.Implode (",") + "|" + d.Implode (",")));
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})" />
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2&gt;&gt; Zip&lt;T1,T2&gt; (this System.Collections.Generic.IEnumerable&lt;T1&gt; self, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
        <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
        <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
        <summary>
          Creates and returns an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          containing the corresponding items from 
          <paramref name="self" /> and <paramref name="source2" />.
        </summary>
        <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          containing the corresponding items from 
          <paramref name="self" /> and <paramref name="source2" />.
        </returns>
        <remarks>
          <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
            where each <see cref="T:Cadenza.Tuple{T1,T2}" /> contains an
            element from <paramref name="self" /> and <paramref name="source2" /> 
            with the same element index.
          </para>
          <para>
            The number of items in the list returned is equal to the shorter
            of <paramref name="self" /> and <paramref name="source2" />.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Zip2">Assert.AreEqual ("1,5|2,4|",
		new[]{1,2}.Zip (new[]{5,4,3})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1}|", e.Item1, e.Item2)).ToString ());
Assert.AreEqual ("",
		new int[]{}.Zip (new[]{5,4,3})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1}|", e.Item1, e.Item2)).ToString ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" /> or <paramref name="source2" /> 
          is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.SelectFromEach``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Unzip``2(System.Collections.Generic.IEnumerable{Cadenza.Tuple{``0,``1}})" />
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2,T3&gt;&gt; Zip&lt;T1,T2,T3&gt; (this System.Collections.Generic.IEnumerable&lt;T1&gt; self, System.Collections.Generic.IEnumerable&lt;T2&gt; source2, System.Collections.Generic.IEnumerable&lt;T3&gt; source3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2,T3&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Collections.Generic.IEnumerable&lt;T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
        <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
        <typeparam name="T3">
          The type of elements in the third list.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
        <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
        <param name="source3">
          A <see cref="T:System.Collections.Generic.IEnumerable{T3}" />
          containing elements from the third list.
        </param>
        <summary>
          Creates and returns an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3}}" />
          containing the corresponding items from 
          <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
        </summary>
        <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          containing the corresponding items from 
          <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
        </returns>
        <remarks>
          <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
            where each <see cref="T:Cadenza.Tuple{T1,T2}" /> contains an
            element from each of
            <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />
            with the same element index.
          </para>
          <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Zip3">Assert.AreEqual ("1,3,5|2,4,6|",
		new[]{1,2}.Zip (new[]{3,4,5,6}, new[]{5,6,7})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1},{2}|", e.Item1, e.Item2, e.Item3)).ToString ());
Assert.AreEqual ("",
		new int[]{}.Zip (new[]{5,4,3}, new[]{1,2,3})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1},{2}|", e.Item1, e.Item2, e.Item3)).ToString ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" />, <paramref name="source2" />, or <paramref name="source3" /> 
          is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.SelectFromEach``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})" />
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Unzip``3(System.Collections.Generic.IEnumerable{Cadenza.Tuple{``0,``1,``2}})" />
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;T1,T2,T3,T4&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2,T3,T4&gt;&gt; Zip&lt;T1,T2,T3,T4&gt; (this System.Collections.Generic.IEnumerable&lt;T1&gt; self, System.Collections.Generic.IEnumerable&lt;T2&gt; source2, System.Collections.Generic.IEnumerable&lt;T3&gt; source3, System.Collections.Generic.IEnumerable&lt;T4&gt; source4);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Cadenza.Tuple&lt;T1,T2,T3,T4&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" RefType="this" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Collections.Generic.IEnumerable&lt;T3&gt;" />
        <Parameter Name="source4" Type="System.Collections.Generic.IEnumerable&lt;T4&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
        <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
        <typeparam name="T3">
          The type of elements in the third list.
        </typeparam>
        <typeparam name="T4">
          The type of elements in the fourth list.
        </typeparam>
        <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
        <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
        <param name="source3">
          A <see cref="T:System.Collections.Generic.IEnumerable{T3}" />
          containing elements from the third list.
        </param>
        <param name="source4">
          A <see cref="T:System.Collections.Generic.IEnumerable{T4}" />
          containing elements from the fourth list.
        </param>
        <summary>
          Creates and returns an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3,T4}}" />
          containing the corresponding items from 
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
        </summary>
        <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          containing the corresponding items from 
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
        </returns>
        <remarks>
          <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
            where each <see cref="T:Cadenza.Tuple{T1,T2}" /> contains an
            element from each of
            <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />
            with the same element index.
          </para>
          <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
          </para>
          <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableTest.cs#Zip4">Assert.AreEqual ("1,3,5,7|2,4,6,8|",
		new[]{1,2}.Zip (new[]{3,4,5,6}, new[]{5,6,7}, new[]{7,8})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1},{2},{3}|", e.Item1, e.Item2, e.Item3, e.Item4)).ToString ());
Assert.AreEqual ("",
		new int[]{}.Zip (new[]{3,4,5,6}, new[]{5,6,7}, new[]{7,8})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1},{2},{3}|", e.Item1, e.Item2, e.Item3, e.Item4)).ToString ());
</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, or <paramref name="source4" />
          is <see langword="null" />.
        </exception>
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.SelectFromEach``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})" />
        <altmember cref="M:Cadenza.Collections.EnumerableCoda.Unzip``4(System.Collections.Generic.IEnumerable{Cadenza.Tuple{``0,``1,``2,``3}})" />
      </Docs>
    </Member>
  </Members>
</Type>
