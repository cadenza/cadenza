<Type Name="FuncCoda" FullName="Cadenza.FuncCoda">
  <TypeSignature Language="C#" Value="public static class FuncCoda" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit FuncCoda extends System.Object" />
  <AssemblyInfo>
    <AssemblyName>Cadenza</AssemblyName>
    <AssemblyVersion>0.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
            Provides extension methods on <see cref="T:System.Action{T}" />,
            <see cref="T:System.Func{T,TResult}" />, and related delegates.
            </summary>
    <remarks>
      <para>
        <see cref="T:Cadenza.FuncCoda" /> provides methods methods for:
            </para>
      <list type="bullet">
        <item>
          <term>
            Delegate currying and partial application (<see cref="M:Cadenza.DelegateCoda.Curry" />)
            </term>
        </item>
        <item>
          <term>
            Delegate composition (<see cref="M:Cadenza.DelegateCoda.Compose" />)
            </term>
        </item>
        <item>
          <term>
            Timing generation (<see cref="M:Cadenza.DelegateCoda.Timings" />)
            </term>
        </item>
      </list>
      <para>
            Currying via partial application is a way to easily transform
            functions which accept N arguments into functions which accept
            N-1 arguments, by "fixing" arguments with a value.
            </para>
      <code lang="C#">
            // partial application:
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,int,int&gt;     f_3      = function.Curry (3);
            Func&lt;int&gt;             f_321    = function.Curry (3, 2, 1);
            Console.WriteLine (f_3 (2, 1));  // prints (3 + 2 + 1) == "6"
            Console.WriteLine (f_321 ());    // prints (3 + 2 + 1) == "6"</code>
      <para>
            "Traditional" currying converts a delegate that accepts N arguments
            into a delegate which accepts only one argument, but when invoked may
            return a further delegate (etc.) until the final value is returned.
            </para>
      <code lang="C#">
            // traditional currying:
            Func&lt;int, Func&lt;int, Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Func&lt;int, Func&lt;int, int&gt;&gt;            fc_1  = curry (1);
            Func&lt;int, int&gt;                       fc_12 = fc_1 (2);
            Console.WriteLine (fc_12 (3));        // prints (3 + 2 + 1) == "6"
            Console.WriteLine (curry (3)(2)(1));  // prints (3 + 2 + 1) == "6"</code>
      <para>
            Composition is a way to easy chain (or pipe) together multiple delegates
            so that the return value of a "composer" delegate is used as the input
            parameter for the chained delegate:
            </para>
      <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
      <para>
            All possible argument and return delegate permutations are provided
            for the <see cref="T:System.Func{T,TResult}" /> and related types.
            </para>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Compose&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;TResult&gt; Compose&lt;T,TResult&gt; (this Func&lt;T,TResult&gt; self, Func&lt;T&gt; composer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`1&lt;!!TResult&gt; Compose&lt;T, TResult&gt;(class System.Func`2&lt;!!T, !!TResult&gt; self, class System.Func`1&lt;!!T&gt; composer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T,TResult&gt;" RefType="this" />
        <Parameter Name="composer" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
            The <see cref="T:System.Func{T}" /> return type, and <see cref="T:System.Func{T,TResult}" /> argument type.
            </typeparam>
        <typeparam name="TResult">
            The <see cref="T:System.Func{T,TResult}" /> return type.
            </typeparam>
        <param name="self">
            The <see cref="T:System.Func{T,TResult}" /> to compose.
            </param>
        <param name="composer">
            The <see cref="T:System.Func{T}" /> to compose with <paramref name="self" />.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
        <remarks>
          <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
          <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="self" /> is <see langword="null" />.
            </para>
          <para>-or-</para>
          <para>
            <paramref name="composer" /> is <see langword="null" />.
            </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Compose&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T1,TResult&gt; Compose&lt;T1,T2,TResult&gt; (this Func&lt;T2,TResult&gt; self, Func&lt;T1,T2&gt; composer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T1, !!TResult&gt; Compose&lt;T1, T2, TResult&gt;(class System.Func`2&lt;!!T2, !!TResult&gt; self, class System.Func`2&lt;!!T1, !!T2&gt; composer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T1,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T2,TResult&gt;" RefType="this" />
        <Parameter Name="composer" Type="System.Func&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">
            The <see cref="T:System.Func{T1,T2}" /> return type, and <see cref="T:System.Func{T2,TResult}" /> argument type.
            </typeparam>
        <typeparam name="TResult">
            The <see cref="T:System.Func{T2,TResult}" /> return type.
            </typeparam>
        <param name="self">
            The <see cref="T:System.Func{T2,TResult}" /> to compose.
            </param>
        <param name="composer">
            The <see cref="T:System.Func{T1,T2}" /> to compose with <paramref name="self" />.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T1,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T1,TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
        <remarks>
          <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
          <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="self" /> is <see langword="null" />.
            </para>
          <para>-or-</para>
          <para>
            <paramref name="composer" /> is <see langword="null" />.
            </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Compose&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T1,T2,TResult&gt; Compose&lt;T1,T2,T3,TResult&gt; (this Func&lt;T3,TResult&gt; self, Func&lt;T1,T2,T3&gt; composer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`3&lt;!!T1, !!T2, !!TResult&gt; Compose&lt;T1, T2, T3, TResult&gt;(class System.Func`2&lt;!!T3, !!TResult&gt; self, class System.Func`3&lt;!!T1, !!T2, !!T3&gt; composer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T1,T2,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T3,TResult&gt;" RefType="this" />
        <Parameter Name="composer" Type="System.Func&lt;T1,T2,T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3}" /> parameter type.
            </typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">
            The <see cref="T:System.Func{T1,T2,T3}" /> return type, and <see cref="T:System.Func{T3,TResult}" /> argument type.
            </typeparam>
        <typeparam name="TResult">
            The <see cref="T:System.Func{T3,TResult}" /> return type.
            </typeparam>
        <param name="self">
            The <see cref="T:System.Func{T3,TResult}" /> to compose.
            </param>
        <param name="composer">
            The <see cref="T:System.Func{T1,T2,T3}" /> to compose with <paramref name="self" />.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T1,T2,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T1,T2,TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
        <remarks>
          <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
          <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="self" /> is <see langword="null" />.
            </para>
          <para>-or-</para>
          <para>
            <paramref name="composer" /> is <see langword="null" />.
            </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Compose&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T1,T2,T3,TResult&gt; Compose&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T4,TResult&gt; self, Func&lt;T1,T2,T3,T4&gt; composer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`4&lt;!!T1, !!T2, !!T3, !!TResult&gt; Compose&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`2&lt;!!T4, !!TResult&gt; self, class System.Func`4&lt;!!T1, !!T2, !!T3, !!T4&gt; composer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T1,T2,T3,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T4,TResult&gt;" RefType="this" />
        <Parameter Name="composer" Type="System.Func&lt;T1,T2,T3,T4&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="T4">
            The <see cref="T:System.Func{T1,T2,T3,T4}" /> return type, and <see cref="T:System.Func{T4,TResult}" /> argument type.
            </typeparam>
        <typeparam name="TResult">
            The <see cref="T:System.Func{T4,TResult}" /> return type.
            </typeparam>
        <param name="self">
            The <see cref="T:System.Func{T4,TResult}" /> to compose.
            </param>
        <param name="composer">
            The <see cref="T:System.Func{T1,T2,T3,T4}" /> to compose with <paramref name="self" />.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T1,T2,T3,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T1,T2,T3,TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
        <remarks>
          <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
          <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="self" /> is <see langword="null" />.
            </para>
          <para>-or-</para>
          <para>
            <paramref name="composer" /> is <see langword="null" />.
            </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Compose&lt;T1,T2,T3,T4,T5,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T1,T2,T3,T4,TResult&gt; Compose&lt;T1,T2,T3,T4,T5,TResult&gt; (this Func&lt;T5,TResult&gt; self, Func&lt;T1,T2,T3,T4,T5&gt; composer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; Compose&lt;T1, T2, T3, T4, T5, TResult&gt;(class System.Func`2&lt;!!T5, !!TResult&gt; self, class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!T5&gt; composer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T1,T2,T3,T4,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="T5" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T5,TResult&gt;" RefType="this" />
        <Parameter Name="composer" Type="System.Func&lt;T1,T2,T3,T4,T5&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> parameter type.
            </typeparam>
        <typeparam name="T4">To be added.</typeparam>
        <typeparam name="T5">
            The <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> return type, and <see cref="T:System.Func{T5,TResult}" /> argument type.
            </typeparam>
        <typeparam name="TResult">
            The <see cref="T:System.Func{T5,TResult}" /> return type.
            </typeparam>
        <param name="self">
            The <see cref="T:System.Func{T5,TResult}" /> to compose.
            </param>
        <param name="composer">
            The <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> to compose with <paramref name="self" />.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
        <remarks>
          <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
          <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <para>
            <paramref name="self" /> is <see langword="null" />.
            </para>
          <para>-or-</para>
          <para>
            <paramref name="composer" /> is <see langword="null" />.
            </para>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T,TResult&gt; Curry&lt;T,TResult&gt; (this Func&lt;T,TResult&gt; self);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T, !!TResult&gt; Curry&lt;T, TResult&gt;(class System.Func`2&lt;!!T, !!TResult&gt; self) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T,TResult&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">
            The first value type.
            </typeparam>
        <typeparam name="TResult">
            The return value type.
            </typeparam>
        <param name="self">
            The <see cref="T:System.Func{T,TResult}" /> to curry.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T,TResult}" /> for currying.
            </summary>
        <returns>
            A <see cref="T:System.Func{T,TResult}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
        <remarks>
          <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
          <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;TResult&gt; Curry&lt;T,TResult&gt; (this Func&lt;T,TResult&gt; self, Cadenza.Tuple&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`1&lt;!!TResult&gt; Curry&lt;T, TResult&gt;(class System.Func`2&lt;!!T, !!TResult&gt; self, class Cadenza.Tuple`1&lt;!!T&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
            A <see cref="T:System.Func{T,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;TResult&gt; Curry&lt;T,TResult&gt; (this Func&lt;T,TResult&gt; self, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`1&lt;!!TResult&gt; Curry&lt;T, TResult&gt;(class System.Func`2&lt;!!T, !!TResult&gt; self, !!T value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T,TResult&gt;" RefType="this" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
            A <see cref="T:System.Func{T,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T,TResult}" /> to curry.
            </param>
        <param name="value">
            A value of type <typeparamref name="T" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T1,Func&lt;T2,TResult&gt;&gt; Curry&lt;T1,T2,TResult&gt; (this Func&lt;T1,T2,TResult&gt; self);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T1, class System.Func`2&lt;!!T2, !!TResult&gt;&gt; Curry&lt;T1, T2, TResult&gt;(class System.Func`3&lt;!!T1, !!T2, !!TResult&gt; self) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T1,System.Func&lt;T2,TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,TResult&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            The first value type.
            </typeparam>
        <typeparam name="T2">
            The second value type.
            </typeparam>
        <typeparam name="TResult">
            The return value type.
            </typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T1,System.Func{T2,TResult}}" /> for currying.
            </summary>
        <returns>
            A <see cref="T:System.Func{T1,System.Func{T2,TResult}}" /> which, when invoked, will
            return a <see cref="T:System.Func{T2,TResult}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
        <remarks>
          <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
          <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;TResult&gt; Curry&lt;T1,T2,TResult&gt; (this Func&lt;T1,T2,TResult&gt; self, Cadenza.Tuple&lt;T1,T2&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`1&lt;!!TResult&gt; Curry&lt;T1, T2, TResult&gt;(class System.Func`3&lt;!!T1, !!T2, !!TResult&gt; self, class Cadenza.Tuple`2&lt;!!T1, !!T2&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T2,TResult&gt; Curry&lt;T1,T2,TResult&gt; (this Func&lt;T1,T2,TResult&gt; self, Cadenza.Tuple&lt;T1&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T2, !!TResult&gt; Curry&lt;T1, T2, TResult&gt;(class System.Func`3&lt;!!T1, !!T2, !!TResult&gt; self, class Cadenza.Tuple`1&lt;!!T1&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T2,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T1&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T2,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T2,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T2,TResult&gt; Curry&lt;T1,T2,TResult&gt; (this Func&lt;T1,T2,TResult&gt; self, T1 value1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T2, !!TResult&gt; Curry&lt;T1, T2, TResult&gt;(class System.Func`3&lt;!!T1, !!T2, !!TResult&gt; self, !!T1 value1) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T2,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,TResult&gt;" RefType="this" />
        <Parameter Name="value1" Type="T1" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
        <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T2,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T2,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;TResult&gt; Curry&lt;T1,T2,TResult&gt; (this Func&lt;T1,T2,TResult&gt; self, T1 value1, T2 value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`1&lt;!!TResult&gt; Curry&lt;T1, T2, TResult&gt;(class System.Func`3&lt;!!T1, !!T2, !!TResult&gt; self, !!T1 value1, !!T2 value2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,TResult&gt;" RefType="this" />
        <Parameter Name="value1" Type="T1" />
        <Parameter Name="value2" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
        <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
        <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T1,Func&lt;T2,Func&lt;T3,TResult&gt;&gt;&gt; Curry&lt;T1,T2,T3,TResult&gt; (this Func&lt;T1,T2,T3,TResult&gt; self);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T1, class System.Func`2&lt;!!T2, class System.Func`2&lt;!!T3, !!TResult&gt;&gt;&gt; Curry&lt;T1, T2, T3, TResult&gt;(class System.Func`4&lt;!!T1, !!T2, !!T3, !!TResult&gt; self) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T1,System.Func&lt;T2,System.Func&lt;T3,TResult&gt;&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,TResult&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            The first value type.
            </typeparam>
        <typeparam name="T2">
            The second value type.
            </typeparam>
        <typeparam name="T3">
            The third value type.
            </typeparam>
        <typeparam name="TResult">
            The return value type.
            </typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,TResult}}}" /> for currying.
            </summary>
        <returns>
            A <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,TResult}}}" /> which, when invoked, will
            return a <see cref="T:System.Func{T2,System.Func{T3,TResult}}" /> which, when invoked, will return a <see cref="T:System.Func{T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
        <remarks>
          <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
          <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;TResult&gt; Curry&lt;T1,T2,T3,TResult&gt; (this Func&lt;T1,T2,T3,TResult&gt; self, Cadenza.Tuple&lt;T1,T2,T3&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`1&lt;!!TResult&gt; Curry&lt;T1, T2, T3, TResult&gt;(class System.Func`4&lt;!!T1, !!T2, !!T3, !!TResult&gt; self, class Cadenza.Tuple`3&lt;!!T1, !!T2, !!T3&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T1,T2,T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T3,TResult&gt; Curry&lt;T1,T2,T3,TResult&gt; (this Func&lt;T1,T2,T3,TResult&gt; self, Cadenza.Tuple&lt;T1,T2&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T3, !!TResult&gt; Curry&lt;T1, T2, T3, TResult&gt;(class System.Func`4&lt;!!T1, !!T2, !!T3, !!TResult&gt; self, class Cadenza.Tuple`2&lt;!!T1, !!T2&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T3,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T3,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T2,T3,TResult&gt; Curry&lt;T1,T2,T3,TResult&gt; (this Func&lt;T1,T2,T3,TResult&gt; self, Cadenza.Tuple&lt;T1&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`3&lt;!!T2, !!T3, !!TResult&gt; Curry&lt;T1, T2, T3, TResult&gt;(class System.Func`4&lt;!!T1, !!T2, !!T3, !!TResult&gt; self, class Cadenza.Tuple`1&lt;!!T1&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T2,T3,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T1&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T2,T3,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T2,T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T2,T3,TResult&gt; Curry&lt;T1,T2,T3,TResult&gt; (this Func&lt;T1,T2,T3,TResult&gt; self, T1 value1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`3&lt;!!T2, !!T3, !!TResult&gt; Curry&lt;T1, T2, T3, TResult&gt;(class System.Func`4&lt;!!T1, !!T2, !!T3, !!TResult&gt; self, !!T1 value1) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T2,T3,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,TResult&gt;" RefType="this" />
        <Parameter Name="value1" Type="T1" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
        <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T2,T3,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T2,T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T3,TResult&gt; Curry&lt;T1,T2,T3,TResult&gt; (this Func&lt;T1,T2,T3,TResult&gt; self, T1 value1, T2 value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T3, !!TResult&gt; Curry&lt;T1, T2, T3, TResult&gt;(class System.Func`4&lt;!!T1, !!T2, !!T3, !!TResult&gt; self, !!T1 value1, !!T2 value2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T3,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,TResult&gt;" RefType="this" />
        <Parameter Name="value1" Type="T1" />
        <Parameter Name="value2" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
        <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
        <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T3,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;TResult&gt; Curry&lt;T1,T2,T3,TResult&gt; (this Func&lt;T1,T2,T3,TResult&gt; self, T1 value1, T2 value2, T3 value3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`1&lt;!!TResult&gt; Curry&lt;T1, T2, T3, TResult&gt;(class System.Func`4&lt;!!T1, !!T2, !!T3, !!TResult&gt; self, !!T1 value1, !!T2 value2, !!T3 value3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,TResult&gt;" RefType="this" />
        <Parameter Name="value1" Type="T1" />
        <Parameter Name="value2" Type="T2" />
        <Parameter Name="value3" Type="T3" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
        <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
        <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
        <param name="value3">
            A value of type <typeparamref name="T3" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T1,Func&lt;T2,Func&lt;T3,Func&lt;T4,TResult&gt;&gt;&gt;&gt; Curry&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T1,T2,T3,T4,TResult&gt; self);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T1, class System.Func`2&lt;!!T2, class System.Func`2&lt;!!T3, class System.Func`2&lt;!!T4, !!TResult&gt;&gt;&gt;&gt; Curry&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; self) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T1,System.Func&lt;T2,System.Func&lt;T3,System.Func&lt;T4,TResult&gt;&gt;&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            The first value type.
            </typeparam>
        <typeparam name="T2">
            The second value type.
            </typeparam>
        <typeparam name="T3">
            The third value type.
            </typeparam>
        <typeparam name="T4">
            The fourth value type.
            </typeparam>
        <typeparam name="TResult">
            The return value type.
            </typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,System.Func{T4,TResult}}}}" /> for currying.
            </summary>
        <returns>
            A <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,System.Func{T4,TResult}}}}" /> which, when invoked, will
            return a <see cref="T:System.Func{T2,System.Func{T3,System.Func{T4,TResult}}}" /> which, when invoked, will return a <see cref="T:System.Func{T3,System.Func{T4,TResult}}" /> which, when invoked, will return a <see cref="T:System.Func{T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
        <remarks>
          <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
          <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;TResult&gt; Curry&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T1,T2,T3,T4,TResult&gt; self, Cadenza.Tuple&lt;T1,T2,T3,T4&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`1&lt;!!TResult&gt; Curry&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; self, class Cadenza.Tuple`4&lt;!!T1, !!T2, !!T3, !!T4&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T1,T2,T3,T4&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T4,TResult&gt; Curry&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T1,T2,T3,T4,TResult&gt; self, Cadenza.Tuple&lt;T1,T2,T3&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T4, !!TResult&gt; Curry&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; self, class Cadenza.Tuple`3&lt;!!T1, !!T2, !!T3&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T4,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T1,T2,T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T4,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T3,T4,TResult&gt; Curry&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T1,T2,T3,T4,TResult&gt; self, Cadenza.Tuple&lt;T1,T2&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`3&lt;!!T3, !!T4, !!TResult&gt; Curry&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; self, class Cadenza.Tuple`2&lt;!!T1, !!T2&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T3,T4,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T3,T4,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T2,T3,T4,TResult&gt; Curry&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T1,T2,T3,T4,TResult&gt; self, Cadenza.Tuple&lt;T1&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`4&lt;!!T2, !!T3, !!T4, !!TResult&gt; Curry&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; self, class Cadenza.Tuple`1&lt;!!T1&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T2,T3,T4,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" RefType="this" />
        <Parameter Name="values" Type="Cadenza.Tuple&lt;T1&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
        <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1}" /> which contains the values to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T2,T3,T4,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T2,T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T2,T3,T4,TResult&gt; Curry&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T1,T2,T3,T4,TResult&gt; self, T1 value1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`4&lt;!!T2, !!T3, !!T4, !!TResult&gt; Curry&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; self, !!T1 value1) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T2,T3,T4,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" RefType="this" />
        <Parameter Name="value1" Type="T1" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
        <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T2,T3,T4,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T2,T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T3,T4,TResult&gt; Curry&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T1,T2,T3,T4,TResult&gt; self, T1 value1, T2 value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`3&lt;!!T3, !!T4, !!TResult&gt; Curry&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; self, !!T1 value1, !!T2 value2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T3,T4,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" RefType="this" />
        <Parameter Name="value1" Type="T1" />
        <Parameter Name="value2" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
        <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
        <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T3,T4,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;T4,TResult&gt; Curry&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T1,T2,T3,T4,TResult&gt; self, T1 value1, T2 value2, T3 value3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`2&lt;!!T4, !!TResult&gt; Curry&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; self, !!T1 value1, !!T2 value2, !!T3 value3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;T4,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" RefType="this" />
        <Parameter Name="value1" Type="T1" />
        <Parameter Name="value2" Type="T2" />
        <Parameter Name="value3" Type="T3" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
        <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
        <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
        <param name="value3">
            A value of type <typeparamref name="T3" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{T4,TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Curry&lt;T1,T2,T3,T4,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Func&lt;TResult&gt; Curry&lt;T1,T2,T3,T4,TResult&gt; (this Func&lt;T1,T2,T3,T4,TResult&gt; self, T1 value1, T2 value2, T3 value3, T4 value4);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Func`1&lt;!!TResult&gt; Curry&lt;T1, T2, T3, T4, TResult&gt;(class System.Func`5&lt;!!T1, !!T2, !!T3, !!T4, !!TResult&gt; self, !!T1 value1, !!T2 value2, !!T3 value3, !!T4 value4) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T4" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="self" Type="System.Func&lt;T1,T2,T3,T4,TResult&gt;" RefType="this" />
        <Parameter Name="value1" Type="T1" />
        <Parameter Name="value2" Type="T2" />
        <Parameter Name="value3" Type="T3" />
        <Parameter Name="value4" Type="T4" />
      </Parameters>
      <Docs>
        <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
        <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
        <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
        <param name="value3">
            A value of type <typeparamref name="T3" /> to fix.
            </param>
        <param name="value4">
            A value of type <typeparamref name="T4" /> to fix.
            </param>
        <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
        <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
      </Docs>
    </Member>
  </Members>
</Type>
